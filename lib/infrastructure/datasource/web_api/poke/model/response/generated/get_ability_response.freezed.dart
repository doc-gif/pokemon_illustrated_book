// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../get_ability_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

GetAbilityResponse _$GetAbilityResponseFromJson(Map<String, dynamic> json) {
  return _GetAbilityResponse.fromJson(json);
}

/// @nodoc
mixin _$GetAbilityResponse {
  List<EffectChanges>? get effectChanges => throw _privateConstructorUsedError;
  List<EffectEntries>? get effectEntries => throw _privateConstructorUsedError;
  List<FlavorTextEntries>? get flavorTextEntries =>
      throw _privateConstructorUsedError;
  Generation? get generation => throw _privateConstructorUsedError;
  int? get id => throw _privateConstructorUsedError;
  bool? get isMainSeries => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  List<Names>? get names => throw _privateConstructorUsedError;
  List<Pokemon>? get pokemon => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GetAbilityResponseCopyWith<GetAbilityResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetAbilityResponseCopyWith<$Res> {
  factory $GetAbilityResponseCopyWith(
          GetAbilityResponse value, $Res Function(GetAbilityResponse) then) =
      _$GetAbilityResponseCopyWithImpl<$Res, GetAbilityResponse>;
  @useResult
  $Res call(
      {List<EffectChanges>? effectChanges,
      List<EffectEntries>? effectEntries,
      List<FlavorTextEntries>? flavorTextEntries,
      Generation? generation,
      int? id,
      bool? isMainSeries,
      String? name,
      List<Names>? names,
      List<Pokemon>? pokemon});

  $GenerationCopyWith<$Res>? get generation;
}

/// @nodoc
class _$GetAbilityResponseCopyWithImpl<$Res, $Val extends GetAbilityResponse>
    implements $GetAbilityResponseCopyWith<$Res> {
  _$GetAbilityResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effectChanges = freezed,
    Object? effectEntries = freezed,
    Object? flavorTextEntries = freezed,
    Object? generation = freezed,
    Object? id = freezed,
    Object? isMainSeries = freezed,
    Object? name = freezed,
    Object? names = freezed,
    Object? pokemon = freezed,
  }) {
    return _then(_value.copyWith(
      effectChanges: freezed == effectChanges
          ? _value.effectChanges
          : effectChanges // ignore: cast_nullable_to_non_nullable
              as List<EffectChanges>?,
      effectEntries: freezed == effectEntries
          ? _value.effectEntries
          : effectEntries // ignore: cast_nullable_to_non_nullable
              as List<EffectEntries>?,
      flavorTextEntries: freezed == flavorTextEntries
          ? _value.flavorTextEntries
          : flavorTextEntries // ignore: cast_nullable_to_non_nullable
              as List<FlavorTextEntries>?,
      generation: freezed == generation
          ? _value.generation
          : generation // ignore: cast_nullable_to_non_nullable
              as Generation?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      isMainSeries: freezed == isMainSeries
          ? _value.isMainSeries
          : isMainSeries // ignore: cast_nullable_to_non_nullable
              as bool?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      names: freezed == names
          ? _value.names
          : names // ignore: cast_nullable_to_non_nullable
              as List<Names>?,
      pokemon: freezed == pokemon
          ? _value.pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as List<Pokemon>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GenerationCopyWith<$Res>? get generation {
    if (_value.generation == null) {
      return null;
    }

    return $GenerationCopyWith<$Res>(_value.generation!, (value) {
      return _then(_value.copyWith(generation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GetAbilityResponseImplCopyWith<$Res>
    implements $GetAbilityResponseCopyWith<$Res> {
  factory _$$GetAbilityResponseImplCopyWith(_$GetAbilityResponseImpl value,
          $Res Function(_$GetAbilityResponseImpl) then) =
      __$$GetAbilityResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<EffectChanges>? effectChanges,
      List<EffectEntries>? effectEntries,
      List<FlavorTextEntries>? flavorTextEntries,
      Generation? generation,
      int? id,
      bool? isMainSeries,
      String? name,
      List<Names>? names,
      List<Pokemon>? pokemon});

  @override
  $GenerationCopyWith<$Res>? get generation;
}

/// @nodoc
class __$$GetAbilityResponseImplCopyWithImpl<$Res>
    extends _$GetAbilityResponseCopyWithImpl<$Res, _$GetAbilityResponseImpl>
    implements _$$GetAbilityResponseImplCopyWith<$Res> {
  __$$GetAbilityResponseImplCopyWithImpl(_$GetAbilityResponseImpl _value,
      $Res Function(_$GetAbilityResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effectChanges = freezed,
    Object? effectEntries = freezed,
    Object? flavorTextEntries = freezed,
    Object? generation = freezed,
    Object? id = freezed,
    Object? isMainSeries = freezed,
    Object? name = freezed,
    Object? names = freezed,
    Object? pokemon = freezed,
  }) {
    return _then(_$GetAbilityResponseImpl(
      effectChanges: freezed == effectChanges
          ? _value._effectChanges
          : effectChanges // ignore: cast_nullable_to_non_nullable
              as List<EffectChanges>?,
      effectEntries: freezed == effectEntries
          ? _value._effectEntries
          : effectEntries // ignore: cast_nullable_to_non_nullable
              as List<EffectEntries>?,
      flavorTextEntries: freezed == flavorTextEntries
          ? _value._flavorTextEntries
          : flavorTextEntries // ignore: cast_nullable_to_non_nullable
              as List<FlavorTextEntries>?,
      generation: freezed == generation
          ? _value.generation
          : generation // ignore: cast_nullable_to_non_nullable
              as Generation?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      isMainSeries: freezed == isMainSeries
          ? _value.isMainSeries
          : isMainSeries // ignore: cast_nullable_to_non_nullable
              as bool?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      names: freezed == names
          ? _value._names
          : names // ignore: cast_nullable_to_non_nullable
              as List<Names>?,
      pokemon: freezed == pokemon
          ? _value._pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as List<Pokemon>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GetAbilityResponseImpl
    with DiagnosticableTreeMixin
    implements _GetAbilityResponse {
  const _$GetAbilityResponseImpl(
      {final List<EffectChanges>? effectChanges,
      final List<EffectEntries>? effectEntries,
      final List<FlavorTextEntries>? flavorTextEntries,
      this.generation,
      this.id,
      this.isMainSeries,
      this.name,
      final List<Names>? names,
      final List<Pokemon>? pokemon})
      : _effectChanges = effectChanges,
        _effectEntries = effectEntries,
        _flavorTextEntries = flavorTextEntries,
        _names = names,
        _pokemon = pokemon;

  factory _$GetAbilityResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$GetAbilityResponseImplFromJson(json);

  final List<EffectChanges>? _effectChanges;
  @override
  List<EffectChanges>? get effectChanges {
    final value = _effectChanges;
    if (value == null) return null;
    if (_effectChanges is EqualUnmodifiableListView) return _effectChanges;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<EffectEntries>? _effectEntries;
  @override
  List<EffectEntries>? get effectEntries {
    final value = _effectEntries;
    if (value == null) return null;
    if (_effectEntries is EqualUnmodifiableListView) return _effectEntries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<FlavorTextEntries>? _flavorTextEntries;
  @override
  List<FlavorTextEntries>? get flavorTextEntries {
    final value = _flavorTextEntries;
    if (value == null) return null;
    if (_flavorTextEntries is EqualUnmodifiableListView)
      return _flavorTextEntries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Generation? generation;
  @override
  final int? id;
  @override
  final bool? isMainSeries;
  @override
  final String? name;
  final List<Names>? _names;
  @override
  List<Names>? get names {
    final value = _names;
    if (value == null) return null;
    if (_names is EqualUnmodifiableListView) return _names;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Pokemon>? _pokemon;
  @override
  List<Pokemon>? get pokemon {
    final value = _pokemon;
    if (value == null) return null;
    if (_pokemon is EqualUnmodifiableListView) return _pokemon;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GetAbilityResponse(effectChanges: $effectChanges, effectEntries: $effectEntries, flavorTextEntries: $flavorTextEntries, generation: $generation, id: $id, isMainSeries: $isMainSeries, name: $name, names: $names, pokemon: $pokemon)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GetAbilityResponse'))
      ..add(DiagnosticsProperty('effectChanges', effectChanges))
      ..add(DiagnosticsProperty('effectEntries', effectEntries))
      ..add(DiagnosticsProperty('flavorTextEntries', flavorTextEntries))
      ..add(DiagnosticsProperty('generation', generation))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('isMainSeries', isMainSeries))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('names', names))
      ..add(DiagnosticsProperty('pokemon', pokemon));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetAbilityResponseImpl &&
            const DeepCollectionEquality()
                .equals(other._effectChanges, _effectChanges) &&
            const DeepCollectionEquality()
                .equals(other._effectEntries, _effectEntries) &&
            const DeepCollectionEquality()
                .equals(other._flavorTextEntries, _flavorTextEntries) &&
            (identical(other.generation, generation) ||
                other.generation == generation) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.isMainSeries, isMainSeries) ||
                other.isMainSeries == isMainSeries) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._names, _names) &&
            const DeepCollectionEquality().equals(other._pokemon, _pokemon));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_effectChanges),
      const DeepCollectionEquality().hash(_effectEntries),
      const DeepCollectionEquality().hash(_flavorTextEntries),
      generation,
      id,
      isMainSeries,
      name,
      const DeepCollectionEquality().hash(_names),
      const DeepCollectionEquality().hash(_pokemon));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetAbilityResponseImplCopyWith<_$GetAbilityResponseImpl> get copyWith =>
      __$$GetAbilityResponseImplCopyWithImpl<_$GetAbilityResponseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GetAbilityResponseImplToJson(
      this,
    );
  }
}

abstract class _GetAbilityResponse implements GetAbilityResponse {
  const factory _GetAbilityResponse(
      {final List<EffectChanges>? effectChanges,
      final List<EffectEntries>? effectEntries,
      final List<FlavorTextEntries>? flavorTextEntries,
      final Generation? generation,
      final int? id,
      final bool? isMainSeries,
      final String? name,
      final List<Names>? names,
      final List<Pokemon>? pokemon}) = _$GetAbilityResponseImpl;

  factory _GetAbilityResponse.fromJson(Map<String, dynamic> json) =
      _$GetAbilityResponseImpl.fromJson;

  @override
  List<EffectChanges>? get effectChanges;
  @override
  List<EffectEntries>? get effectEntries;
  @override
  List<FlavorTextEntries>? get flavorTextEntries;
  @override
  Generation? get generation;
  @override
  int? get id;
  @override
  bool? get isMainSeries;
  @override
  String? get name;
  @override
  List<Names>? get names;
  @override
  List<Pokemon>? get pokemon;
  @override
  @JsonKey(ignore: true)
  _$$GetAbilityResponseImplCopyWith<_$GetAbilityResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EffectChanges _$EffectChangesFromJson(Map<String, dynamic> json) {
  return _EffectChanges.fromJson(json);
}

/// @nodoc
mixin _$EffectChanges {
  List<EffectEntries>? get effectEntries => throw _privateConstructorUsedError;
  VersionGroup? get versionGroup => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EffectChangesCopyWith<EffectChanges> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EffectChangesCopyWith<$Res> {
  factory $EffectChangesCopyWith(
          EffectChanges value, $Res Function(EffectChanges) then) =
      _$EffectChangesCopyWithImpl<$Res, EffectChanges>;
  @useResult
  $Res call({List<EffectEntries>? effectEntries, VersionGroup? versionGroup});

  $VersionGroupCopyWith<$Res>? get versionGroup;
}

/// @nodoc
class _$EffectChangesCopyWithImpl<$Res, $Val extends EffectChanges>
    implements $EffectChangesCopyWith<$Res> {
  _$EffectChangesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effectEntries = freezed,
    Object? versionGroup = freezed,
  }) {
    return _then(_value.copyWith(
      effectEntries: freezed == effectEntries
          ? _value.effectEntries
          : effectEntries // ignore: cast_nullable_to_non_nullable
              as List<EffectEntries>?,
      versionGroup: freezed == versionGroup
          ? _value.versionGroup
          : versionGroup // ignore: cast_nullable_to_non_nullable
              as VersionGroup?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $VersionGroupCopyWith<$Res>? get versionGroup {
    if (_value.versionGroup == null) {
      return null;
    }

    return $VersionGroupCopyWith<$Res>(_value.versionGroup!, (value) {
      return _then(_value.copyWith(versionGroup: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EffectChangesImplCopyWith<$Res>
    implements $EffectChangesCopyWith<$Res> {
  factory _$$EffectChangesImplCopyWith(
          _$EffectChangesImpl value, $Res Function(_$EffectChangesImpl) then) =
      __$$EffectChangesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<EffectEntries>? effectEntries, VersionGroup? versionGroup});

  @override
  $VersionGroupCopyWith<$Res>? get versionGroup;
}

/// @nodoc
class __$$EffectChangesImplCopyWithImpl<$Res>
    extends _$EffectChangesCopyWithImpl<$Res, _$EffectChangesImpl>
    implements _$$EffectChangesImplCopyWith<$Res> {
  __$$EffectChangesImplCopyWithImpl(
      _$EffectChangesImpl _value, $Res Function(_$EffectChangesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effectEntries = freezed,
    Object? versionGroup = freezed,
  }) {
    return _then(_$EffectChangesImpl(
      effectEntries: freezed == effectEntries
          ? _value._effectEntries
          : effectEntries // ignore: cast_nullable_to_non_nullable
              as List<EffectEntries>?,
      versionGroup: freezed == versionGroup
          ? _value.versionGroup
          : versionGroup // ignore: cast_nullable_to_non_nullable
              as VersionGroup?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EffectChangesImpl
    with DiagnosticableTreeMixin
    implements _EffectChanges {
  const _$EffectChangesImpl(
      {final List<EffectEntries>? effectEntries, this.versionGroup})
      : _effectEntries = effectEntries;

  factory _$EffectChangesImpl.fromJson(Map<String, dynamic> json) =>
      _$$EffectChangesImplFromJson(json);

  final List<EffectEntries>? _effectEntries;
  @override
  List<EffectEntries>? get effectEntries {
    final value = _effectEntries;
    if (value == null) return null;
    if (_effectEntries is EqualUnmodifiableListView) return _effectEntries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final VersionGroup? versionGroup;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'EffectChanges(effectEntries: $effectEntries, versionGroup: $versionGroup)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'EffectChanges'))
      ..add(DiagnosticsProperty('effectEntries', effectEntries))
      ..add(DiagnosticsProperty('versionGroup', versionGroup));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EffectChangesImpl &&
            const DeepCollectionEquality()
                .equals(other._effectEntries, _effectEntries) &&
            (identical(other.versionGroup, versionGroup) ||
                other.versionGroup == versionGroup));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_effectEntries), versionGroup);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EffectChangesImplCopyWith<_$EffectChangesImpl> get copyWith =>
      __$$EffectChangesImplCopyWithImpl<_$EffectChangesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EffectChangesImplToJson(
      this,
    );
  }
}

abstract class _EffectChanges implements EffectChanges {
  const factory _EffectChanges(
      {final List<EffectEntries>? effectEntries,
      final VersionGroup? versionGroup}) = _$EffectChangesImpl;

  factory _EffectChanges.fromJson(Map<String, dynamic> json) =
      _$EffectChangesImpl.fromJson;

  @override
  List<EffectEntries>? get effectEntries;
  @override
  VersionGroup? get versionGroup;
  @override
  @JsonKey(ignore: true)
  _$$EffectChangesImplCopyWith<_$EffectChangesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Language _$LanguageFromJson(Map<String, dynamic> json) {
  return _Language.fromJson(json);
}

/// @nodoc
mixin _$Language {
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LanguageCopyWith<Language> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LanguageCopyWith<$Res> {
  factory $LanguageCopyWith(Language value, $Res Function(Language) then) =
      _$LanguageCopyWithImpl<$Res, Language>;
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class _$LanguageCopyWithImpl<$Res, $Val extends Language>
    implements $LanguageCopyWith<$Res> {
  _$LanguageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LanguageImplCopyWith<$Res>
    implements $LanguageCopyWith<$Res> {
  factory _$$LanguageImplCopyWith(
          _$LanguageImpl value, $Res Function(_$LanguageImpl) then) =
      __$$LanguageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class __$$LanguageImplCopyWithImpl<$Res>
    extends _$LanguageCopyWithImpl<$Res, _$LanguageImpl>
    implements _$$LanguageImplCopyWith<$Res> {
  __$$LanguageImplCopyWithImpl(
      _$LanguageImpl _value, $Res Function(_$LanguageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$LanguageImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LanguageImpl with DiagnosticableTreeMixin implements _Language {
  const _$LanguageImpl({this.name, this.url});

  factory _$LanguageImpl.fromJson(Map<String, dynamic> json) =>
      _$$LanguageImplFromJson(json);

  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Language(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Language'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LanguageImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LanguageImplCopyWith<_$LanguageImpl> get copyWith =>
      __$$LanguageImplCopyWithImpl<_$LanguageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LanguageImplToJson(
      this,
    );
  }
}

abstract class _Language implements Language {
  const factory _Language({final String? name, final String? url}) =
      _$LanguageImpl;

  factory _Language.fromJson(Map<String, dynamic> json) =
      _$LanguageImpl.fromJson;

  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$LanguageImplCopyWith<_$LanguageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

VersionGroup _$VersionGroupFromJson(Map<String, dynamic> json) {
  return _VersionGroup.fromJson(json);
}

/// @nodoc
mixin _$VersionGroup {
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VersionGroupCopyWith<VersionGroup> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersionGroupCopyWith<$Res> {
  factory $VersionGroupCopyWith(
          VersionGroup value, $Res Function(VersionGroup) then) =
      _$VersionGroupCopyWithImpl<$Res, VersionGroup>;
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class _$VersionGroupCopyWithImpl<$Res, $Val extends VersionGroup>
    implements $VersionGroupCopyWith<$Res> {
  _$VersionGroupCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VersionGroupImplCopyWith<$Res>
    implements $VersionGroupCopyWith<$Res> {
  factory _$$VersionGroupImplCopyWith(
          _$VersionGroupImpl value, $Res Function(_$VersionGroupImpl) then) =
      __$$VersionGroupImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class __$$VersionGroupImplCopyWithImpl<$Res>
    extends _$VersionGroupCopyWithImpl<$Res, _$VersionGroupImpl>
    implements _$$VersionGroupImplCopyWith<$Res> {
  __$$VersionGroupImplCopyWithImpl(
      _$VersionGroupImpl _value, $Res Function(_$VersionGroupImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$VersionGroupImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersionGroupImpl with DiagnosticableTreeMixin implements _VersionGroup {
  const _$VersionGroupImpl({this.name, this.url});

  factory _$VersionGroupImpl.fromJson(Map<String, dynamic> json) =>
      _$$VersionGroupImplFromJson(json);

  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VersionGroup(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VersionGroup'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersionGroupImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VersionGroupImplCopyWith<_$VersionGroupImpl> get copyWith =>
      __$$VersionGroupImplCopyWithImpl<_$VersionGroupImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VersionGroupImplToJson(
      this,
    );
  }
}

abstract class _VersionGroup implements VersionGroup {
  const factory _VersionGroup({final String? name, final String? url}) =
      _$VersionGroupImpl;

  factory _VersionGroup.fromJson(Map<String, dynamic> json) =
      _$VersionGroupImpl.fromJson;

  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$VersionGroupImplCopyWith<_$VersionGroupImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EffectEntries _$EffectEntriesFromJson(Map<String, dynamic> json) {
  return _EffectEntries.fromJson(json);
}

/// @nodoc
mixin _$EffectEntries {
  String? get effect => throw _privateConstructorUsedError;
  Language? get language => throw _privateConstructorUsedError;
  String? get shortEffect => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EffectEntriesCopyWith<EffectEntries> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EffectEntriesCopyWith<$Res> {
  factory $EffectEntriesCopyWith(
          EffectEntries value, $Res Function(EffectEntries) then) =
      _$EffectEntriesCopyWithImpl<$Res, EffectEntries>;
  @useResult
  $Res call({String? effect, Language? language, String? shortEffect});

  $LanguageCopyWith<$Res>? get language;
}

/// @nodoc
class _$EffectEntriesCopyWithImpl<$Res, $Val extends EffectEntries>
    implements $EffectEntriesCopyWith<$Res> {
  _$EffectEntriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effect = freezed,
    Object? language = freezed,
    Object? shortEffect = freezed,
  }) {
    return _then(_value.copyWith(
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as String?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      shortEffect: freezed == shortEffect
          ? _value.shortEffect
          : shortEffect // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res>? get language {
    if (_value.language == null) {
      return null;
    }

    return $LanguageCopyWith<$Res>(_value.language!, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EffectEntriesImplCopyWith<$Res>
    implements $EffectEntriesCopyWith<$Res> {
  factory _$$EffectEntriesImplCopyWith(
          _$EffectEntriesImpl value, $Res Function(_$EffectEntriesImpl) then) =
      __$$EffectEntriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? effect, Language? language, String? shortEffect});

  @override
  $LanguageCopyWith<$Res>? get language;
}

/// @nodoc
class __$$EffectEntriesImplCopyWithImpl<$Res>
    extends _$EffectEntriesCopyWithImpl<$Res, _$EffectEntriesImpl>
    implements _$$EffectEntriesImplCopyWith<$Res> {
  __$$EffectEntriesImplCopyWithImpl(
      _$EffectEntriesImpl _value, $Res Function(_$EffectEntriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? effect = freezed,
    Object? language = freezed,
    Object? shortEffect = freezed,
  }) {
    return _then(_$EffectEntriesImpl(
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as String?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      shortEffect: freezed == shortEffect
          ? _value.shortEffect
          : shortEffect // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EffectEntriesImpl
    with DiagnosticableTreeMixin
    implements _EffectEntries {
  const _$EffectEntriesImpl({this.effect, this.language, this.shortEffect});

  factory _$EffectEntriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$EffectEntriesImplFromJson(json);

  @override
  final String? effect;
  @override
  final Language? language;
  @override
  final String? shortEffect;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'EffectEntries(effect: $effect, language: $language, shortEffect: $shortEffect)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'EffectEntries'))
      ..add(DiagnosticsProperty('effect', effect))
      ..add(DiagnosticsProperty('language', language))
      ..add(DiagnosticsProperty('shortEffect', shortEffect));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EffectEntriesImpl &&
            (identical(other.effect, effect) || other.effect == effect) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.shortEffect, shortEffect) ||
                other.shortEffect == shortEffect));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, effect, language, shortEffect);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EffectEntriesImplCopyWith<_$EffectEntriesImpl> get copyWith =>
      __$$EffectEntriesImplCopyWithImpl<_$EffectEntriesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EffectEntriesImplToJson(
      this,
    );
  }
}

abstract class _EffectEntries implements EffectEntries {
  const factory _EffectEntries(
      {final String? effect,
      final Language? language,
      final String? shortEffect}) = _$EffectEntriesImpl;

  factory _EffectEntries.fromJson(Map<String, dynamic> json) =
      _$EffectEntriesImpl.fromJson;

  @override
  String? get effect;
  @override
  Language? get language;
  @override
  String? get shortEffect;
  @override
  @JsonKey(ignore: true)
  _$$EffectEntriesImplCopyWith<_$EffectEntriesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FlavorTextEntries _$FlavorTextEntriesFromJson(Map<String, dynamic> json) {
  return _FlavorTextEntries.fromJson(json);
}

/// @nodoc
mixin _$FlavorTextEntries {
  String? get flavorText => throw _privateConstructorUsedError;
  Language? get language => throw _privateConstructorUsedError;
  VersionGroup? get versionGroup => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FlavorTextEntriesCopyWith<FlavorTextEntries> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlavorTextEntriesCopyWith<$Res> {
  factory $FlavorTextEntriesCopyWith(
          FlavorTextEntries value, $Res Function(FlavorTextEntries) then) =
      _$FlavorTextEntriesCopyWithImpl<$Res, FlavorTextEntries>;
  @useResult
  $Res call(
      {String? flavorText, Language? language, VersionGroup? versionGroup});

  $LanguageCopyWith<$Res>? get language;
  $VersionGroupCopyWith<$Res>? get versionGroup;
}

/// @nodoc
class _$FlavorTextEntriesCopyWithImpl<$Res, $Val extends FlavorTextEntries>
    implements $FlavorTextEntriesCopyWith<$Res> {
  _$FlavorTextEntriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flavorText = freezed,
    Object? language = freezed,
    Object? versionGroup = freezed,
  }) {
    return _then(_value.copyWith(
      flavorText: freezed == flavorText
          ? _value.flavorText
          : flavorText // ignore: cast_nullable_to_non_nullable
              as String?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      versionGroup: freezed == versionGroup
          ? _value.versionGroup
          : versionGroup // ignore: cast_nullable_to_non_nullable
              as VersionGroup?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res>? get language {
    if (_value.language == null) {
      return null;
    }

    return $LanguageCopyWith<$Res>(_value.language!, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VersionGroupCopyWith<$Res>? get versionGroup {
    if (_value.versionGroup == null) {
      return null;
    }

    return $VersionGroupCopyWith<$Res>(_value.versionGroup!, (value) {
      return _then(_value.copyWith(versionGroup: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FlavorTextEntriesImplCopyWith<$Res>
    implements $FlavorTextEntriesCopyWith<$Res> {
  factory _$$FlavorTextEntriesImplCopyWith(_$FlavorTextEntriesImpl value,
          $Res Function(_$FlavorTextEntriesImpl) then) =
      __$$FlavorTextEntriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? flavorText, Language? language, VersionGroup? versionGroup});

  @override
  $LanguageCopyWith<$Res>? get language;
  @override
  $VersionGroupCopyWith<$Res>? get versionGroup;
}

/// @nodoc
class __$$FlavorTextEntriesImplCopyWithImpl<$Res>
    extends _$FlavorTextEntriesCopyWithImpl<$Res, _$FlavorTextEntriesImpl>
    implements _$$FlavorTextEntriesImplCopyWith<$Res> {
  __$$FlavorTextEntriesImplCopyWithImpl(_$FlavorTextEntriesImpl _value,
      $Res Function(_$FlavorTextEntriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flavorText = freezed,
    Object? language = freezed,
    Object? versionGroup = freezed,
  }) {
    return _then(_$FlavorTextEntriesImpl(
      flavorText: freezed == flavorText
          ? _value.flavorText
          : flavorText // ignore: cast_nullable_to_non_nullable
              as String?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      versionGroup: freezed == versionGroup
          ? _value.versionGroup
          : versionGroup // ignore: cast_nullable_to_non_nullable
              as VersionGroup?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FlavorTextEntriesImpl
    with DiagnosticableTreeMixin
    implements _FlavorTextEntries {
  const _$FlavorTextEntriesImpl(
      {this.flavorText, this.language, this.versionGroup});

  factory _$FlavorTextEntriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$FlavorTextEntriesImplFromJson(json);

  @override
  final String? flavorText;
  @override
  final Language? language;
  @override
  final VersionGroup? versionGroup;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlavorTextEntries(flavorText: $flavorText, language: $language, versionGroup: $versionGroup)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlavorTextEntries'))
      ..add(DiagnosticsProperty('flavorText', flavorText))
      ..add(DiagnosticsProperty('language', language))
      ..add(DiagnosticsProperty('versionGroup', versionGroup));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FlavorTextEntriesImpl &&
            (identical(other.flavorText, flavorText) ||
                other.flavorText == flavorText) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.versionGroup, versionGroup) ||
                other.versionGroup == versionGroup));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, flavorText, language, versionGroup);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FlavorTextEntriesImplCopyWith<_$FlavorTextEntriesImpl> get copyWith =>
      __$$FlavorTextEntriesImplCopyWithImpl<_$FlavorTextEntriesImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FlavorTextEntriesImplToJson(
      this,
    );
  }
}

abstract class _FlavorTextEntries implements FlavorTextEntries {
  const factory _FlavorTextEntries(
      {final String? flavorText,
      final Language? language,
      final VersionGroup? versionGroup}) = _$FlavorTextEntriesImpl;

  factory _FlavorTextEntries.fromJson(Map<String, dynamic> json) =
      _$FlavorTextEntriesImpl.fromJson;

  @override
  String? get flavorText;
  @override
  Language? get language;
  @override
  VersionGroup? get versionGroup;
  @override
  @JsonKey(ignore: true)
  _$$FlavorTextEntriesImplCopyWith<_$FlavorTextEntriesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Generation _$GenerationFromJson(Map<String, dynamic> json) {
  return _Generation.fromJson(json);
}

/// @nodoc
mixin _$Generation {
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenerationCopyWith<Generation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenerationCopyWith<$Res> {
  factory $GenerationCopyWith(
          Generation value, $Res Function(Generation) then) =
      _$GenerationCopyWithImpl<$Res, Generation>;
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class _$GenerationCopyWithImpl<$Res, $Val extends Generation>
    implements $GenerationCopyWith<$Res> {
  _$GenerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GenerationImplCopyWith<$Res>
    implements $GenerationCopyWith<$Res> {
  factory _$$GenerationImplCopyWith(
          _$GenerationImpl value, $Res Function(_$GenerationImpl) then) =
      __$$GenerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class __$$GenerationImplCopyWithImpl<$Res>
    extends _$GenerationCopyWithImpl<$Res, _$GenerationImpl>
    implements _$$GenerationImplCopyWith<$Res> {
  __$$GenerationImplCopyWithImpl(
      _$GenerationImpl _value, $Res Function(_$GenerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$GenerationImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GenerationImpl with DiagnosticableTreeMixin implements _Generation {
  const _$GenerationImpl({this.name, this.url});

  factory _$GenerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$GenerationImplFromJson(json);

  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Generation(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Generation'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenerationImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GenerationImplCopyWith<_$GenerationImpl> get copyWith =>
      __$$GenerationImplCopyWithImpl<_$GenerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GenerationImplToJson(
      this,
    );
  }
}

abstract class _Generation implements Generation {
  const factory _Generation({final String? name, final String? url}) =
      _$GenerationImpl;

  factory _Generation.fromJson(Map<String, dynamic> json) =
      _$GenerationImpl.fromJson;

  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$GenerationImplCopyWith<_$GenerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Names _$NamesFromJson(Map<String, dynamic> json) {
  return _Names.fromJson(json);
}

/// @nodoc
mixin _$Names {
  Language? get language => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NamesCopyWith<Names> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NamesCopyWith<$Res> {
  factory $NamesCopyWith(Names value, $Res Function(Names) then) =
      _$NamesCopyWithImpl<$Res, Names>;
  @useResult
  $Res call({Language? language, String? name});

  $LanguageCopyWith<$Res>? get language;
}

/// @nodoc
class _$NamesCopyWithImpl<$Res, $Val extends Names>
    implements $NamesCopyWith<$Res> {
  _$NamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res>? get language {
    if (_value.language == null) {
      return null;
    }

    return $LanguageCopyWith<$Res>(_value.language!, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$NamesImplCopyWith<$Res> implements $NamesCopyWith<$Res> {
  factory _$$NamesImplCopyWith(
          _$NamesImpl value, $Res Function(_$NamesImpl) then) =
      __$$NamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Language? language, String? name});

  @override
  $LanguageCopyWith<$Res>? get language;
}

/// @nodoc
class __$$NamesImplCopyWithImpl<$Res>
    extends _$NamesCopyWithImpl<$Res, _$NamesImpl>
    implements _$$NamesImplCopyWith<$Res> {
  __$$NamesImplCopyWithImpl(
      _$NamesImpl _value, $Res Function(_$NamesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
    Object? name = freezed,
  }) {
    return _then(_$NamesImpl(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NamesImpl with DiagnosticableTreeMixin implements _Names {
  const _$NamesImpl({this.language, this.name});

  factory _$NamesImpl.fromJson(Map<String, dynamic> json) =>
      _$$NamesImplFromJson(json);

  @override
  final Language? language;
  @override
  final String? name;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Names(language: $language, name: $name)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Names'))
      ..add(DiagnosticsProperty('language', language))
      ..add(DiagnosticsProperty('name', name));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NamesImpl &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, language, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NamesImplCopyWith<_$NamesImpl> get copyWith =>
      __$$NamesImplCopyWithImpl<_$NamesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NamesImplToJson(
      this,
    );
  }
}

abstract class _Names implements Names {
  const factory _Names({final Language? language, final String? name}) =
      _$NamesImpl;

  factory _Names.fromJson(Map<String, dynamic> json) = _$NamesImpl.fromJson;

  @override
  Language? get language;
  @override
  String? get name;
  @override
  @JsonKey(ignore: true)
  _$$NamesImplCopyWith<_$NamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Pokemon _$PokemonFromJson(Map<String, dynamic> json) {
  return _Pokemon.fromJson(json);
}

/// @nodoc
mixin _$Pokemon {
  bool? get isHidden => throw _privateConstructorUsedError;
  PokemonName? get pokemon => throw _privateConstructorUsedError;
  int? get slot => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PokemonCopyWith<Pokemon> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokemonCopyWith<$Res> {
  factory $PokemonCopyWith(Pokemon value, $Res Function(Pokemon) then) =
      _$PokemonCopyWithImpl<$Res, Pokemon>;
  @useResult
  $Res call({bool? isHidden, PokemonName? pokemon, int? slot});

  $PokemonNameCopyWith<$Res>? get pokemon;
}

/// @nodoc
class _$PokemonCopyWithImpl<$Res, $Val extends Pokemon>
    implements $PokemonCopyWith<$Res> {
  _$PokemonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isHidden = freezed,
    Object? pokemon = freezed,
    Object? slot = freezed,
  }) {
    return _then(_value.copyWith(
      isHidden: freezed == isHidden
          ? _value.isHidden
          : isHidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      pokemon: freezed == pokemon
          ? _value.pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as PokemonName?,
      slot: freezed == slot
          ? _value.slot
          : slot // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PokemonNameCopyWith<$Res>? get pokemon {
    if (_value.pokemon == null) {
      return null;
    }

    return $PokemonNameCopyWith<$Res>(_value.pokemon!, (value) {
      return _then(_value.copyWith(pokemon: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PokemonImplCopyWith<$Res> implements $PokemonCopyWith<$Res> {
  factory _$$PokemonImplCopyWith(
          _$PokemonImpl value, $Res Function(_$PokemonImpl) then) =
      __$$PokemonImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool? isHidden, PokemonName? pokemon, int? slot});

  @override
  $PokemonNameCopyWith<$Res>? get pokemon;
}

/// @nodoc
class __$$PokemonImplCopyWithImpl<$Res>
    extends _$PokemonCopyWithImpl<$Res, _$PokemonImpl>
    implements _$$PokemonImplCopyWith<$Res> {
  __$$PokemonImplCopyWithImpl(
      _$PokemonImpl _value, $Res Function(_$PokemonImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isHidden = freezed,
    Object? pokemon = freezed,
    Object? slot = freezed,
  }) {
    return _then(_$PokemonImpl(
      isHidden: freezed == isHidden
          ? _value.isHidden
          : isHidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      pokemon: freezed == pokemon
          ? _value.pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as PokemonName?,
      slot: freezed == slot
          ? _value.slot
          : slot // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PokemonImpl with DiagnosticableTreeMixin implements _Pokemon {
  const _$PokemonImpl({this.isHidden, this.pokemon, this.slot});

  factory _$PokemonImpl.fromJson(Map<String, dynamic> json) =>
      _$$PokemonImplFromJson(json);

  @override
  final bool? isHidden;
  @override
  final PokemonName? pokemon;
  @override
  final int? slot;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Pokemon(isHidden: $isHidden, pokemon: $pokemon, slot: $slot)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Pokemon'))
      ..add(DiagnosticsProperty('isHidden', isHidden))
      ..add(DiagnosticsProperty('pokemon', pokemon))
      ..add(DiagnosticsProperty('slot', slot));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PokemonImpl &&
            (identical(other.isHidden, isHidden) ||
                other.isHidden == isHidden) &&
            (identical(other.pokemon, pokemon) || other.pokemon == pokemon) &&
            (identical(other.slot, slot) || other.slot == slot));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, isHidden, pokemon, slot);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PokemonImplCopyWith<_$PokemonImpl> get copyWith =>
      __$$PokemonImplCopyWithImpl<_$PokemonImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PokemonImplToJson(
      this,
    );
  }
}

abstract class _Pokemon implements Pokemon {
  const factory _Pokemon(
      {final bool? isHidden,
      final PokemonName? pokemon,
      final int? slot}) = _$PokemonImpl;

  factory _Pokemon.fromJson(Map<String, dynamic> json) = _$PokemonImpl.fromJson;

  @override
  bool? get isHidden;
  @override
  PokemonName? get pokemon;
  @override
  int? get slot;
  @override
  @JsonKey(ignore: true)
  _$$PokemonImplCopyWith<_$PokemonImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PokemonName _$PokemonNameFromJson(Map<String, dynamic> json) {
  return _PokemonName.fromJson(json);
}

/// @nodoc
mixin _$PokemonName {
  String? get name => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PokemonNameCopyWith<PokemonName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokemonNameCopyWith<$Res> {
  factory $PokemonNameCopyWith(
          PokemonName value, $Res Function(PokemonName) then) =
      _$PokemonNameCopyWithImpl<$Res, PokemonName>;
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class _$PokemonNameCopyWithImpl<$Res, $Val extends PokemonName>
    implements $PokemonNameCopyWith<$Res> {
  _$PokemonNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PokemonNameImplCopyWith<$Res>
    implements $PokemonNameCopyWith<$Res> {
  factory _$$PokemonNameImplCopyWith(
          _$PokemonNameImpl value, $Res Function(_$PokemonNameImpl) then) =
      __$$PokemonNameImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? url});
}

/// @nodoc
class __$$PokemonNameImplCopyWithImpl<$Res>
    extends _$PokemonNameCopyWithImpl<$Res, _$PokemonNameImpl>
    implements _$$PokemonNameImplCopyWith<$Res> {
  __$$PokemonNameImplCopyWithImpl(
      _$PokemonNameImpl _value, $Res Function(_$PokemonNameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? url = freezed,
  }) {
    return _then(_$PokemonNameImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PokemonNameImpl with DiagnosticableTreeMixin implements _PokemonName {
  const _$PokemonNameImpl({this.name, this.url});

  factory _$PokemonNameImpl.fromJson(Map<String, dynamic> json) =>
      _$$PokemonNameImplFromJson(json);

  @override
  final String? name;
  @override
  final String? url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PokemonName(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PokemonName'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PokemonNameImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PokemonNameImplCopyWith<_$PokemonNameImpl> get copyWith =>
      __$$PokemonNameImplCopyWithImpl<_$PokemonNameImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PokemonNameImplToJson(
      this,
    );
  }
}

abstract class _PokemonName implements PokemonName {
  const factory _PokemonName({final String? name, final String? url}) =
      _$PokemonNameImpl;

  factory _PokemonName.fromJson(Map<String, dynamic> json) =
      _$PokemonNameImpl.fromJson;

  @override
  String? get name;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$PokemonNameImplCopyWith<_$PokemonNameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
