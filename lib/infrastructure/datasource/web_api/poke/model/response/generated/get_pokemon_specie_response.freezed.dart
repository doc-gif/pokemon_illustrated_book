// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../get_pokemon_specie_response.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

GetPokemonSpecieResponse _$GetPokemonSpecieResponseFromJson(
    Map<String, dynamic> json) {
  return _GetPokemonSpecieResponse.fromJson(json);
}

/// @nodoc
mixin _$GetPokemonSpecieResponse {
  int get baseHappiness => throw _privateConstructorUsedError;
  int get captureRate => throw _privateConstructorUsedError;
  Color get color => throw _privateConstructorUsedError;
  List<EggGroups> get eggGroups => throw _privateConstructorUsedError;
  EvolutionChain get evolutionChain => throw _privateConstructorUsedError;
  String? get evolvesFromSpecies => throw _privateConstructorUsedError;
  List<FlavorTextEntries> get flavorTextEntries =>
      throw _privateConstructorUsedError;
  List<FormDescriptions> get formDescriptions =>
      throw _privateConstructorUsedError;
  bool get formsSwitchable => throw _privateConstructorUsedError;
  int get genderRate => throw _privateConstructorUsedError;
  List<Genera> get genera => throw _privateConstructorUsedError;
  Generation get generation => throw _privateConstructorUsedError;
  GrowthRate get growthRate => throw _privateConstructorUsedError;
  Habitat get habitat => throw _privateConstructorUsedError;
  bool get hasGenderDifferences => throw _privateConstructorUsedError;
  int get hatchCounter => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  bool get isBaby => throw _privateConstructorUsedError;
  bool get isLegendary => throw _privateConstructorUsedError;
  bool get isMythical => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  List<Names> get names => throw _privateConstructorUsedError;
  int get order => throw _privateConstructorUsedError;
  List<PalParkEncounters> get palParkEncounters =>
      throw _privateConstructorUsedError;
  List<PokedexNumbers> get pokedexNumbers => throw _privateConstructorUsedError;
  Shape get shape => throw _privateConstructorUsedError;
  List<Varieties> get varieties => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GetPokemonSpecieResponseCopyWith<GetPokemonSpecieResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetPokemonSpecieResponseCopyWith<$Res> {
  factory $GetPokemonSpecieResponseCopyWith(GetPokemonSpecieResponse value,
          $Res Function(GetPokemonSpecieResponse) then) =
      _$GetPokemonSpecieResponseCopyWithImpl<$Res, GetPokemonSpecieResponse>;
  @useResult
  $Res call(
      {int baseHappiness,
      int captureRate,
      Color color,
      List<EggGroups> eggGroups,
      EvolutionChain evolutionChain,
      String? evolvesFromSpecies,
      List<FlavorTextEntries> flavorTextEntries,
      List<FormDescriptions> formDescriptions,
      bool formsSwitchable,
      int genderRate,
      List<Genera> genera,
      Generation generation,
      GrowthRate growthRate,
      Habitat habitat,
      bool hasGenderDifferences,
      int hatchCounter,
      int id,
      bool isBaby,
      bool isLegendary,
      bool isMythical,
      String name,
      List<Names> names,
      int order,
      List<PalParkEncounters> palParkEncounters,
      List<PokedexNumbers> pokedexNumbers,
      Shape shape,
      List<Varieties> varieties});

  $ColorCopyWith<$Res> get color;
  $EvolutionChainCopyWith<$Res> get evolutionChain;
  $GenerationCopyWith<$Res> get generation;
  $GrowthRateCopyWith<$Res> get growthRate;
  $HabitatCopyWith<$Res> get habitat;
  $ShapeCopyWith<$Res> get shape;
}

/// @nodoc
class _$GetPokemonSpecieResponseCopyWithImpl<$Res,
        $Val extends GetPokemonSpecieResponse>
    implements $GetPokemonSpecieResponseCopyWith<$Res> {
  _$GetPokemonSpecieResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? baseHappiness = null,
    Object? captureRate = null,
    Object? color = null,
    Object? eggGroups = null,
    Object? evolutionChain = null,
    Object? evolvesFromSpecies = freezed,
    Object? flavorTextEntries = null,
    Object? formDescriptions = null,
    Object? formsSwitchable = null,
    Object? genderRate = null,
    Object? genera = null,
    Object? generation = null,
    Object? growthRate = null,
    Object? habitat = null,
    Object? hasGenderDifferences = null,
    Object? hatchCounter = null,
    Object? id = null,
    Object? isBaby = null,
    Object? isLegendary = null,
    Object? isMythical = null,
    Object? name = null,
    Object? names = null,
    Object? order = null,
    Object? palParkEncounters = null,
    Object? pokedexNumbers = null,
    Object? shape = null,
    Object? varieties = null,
  }) {
    return _then(_value.copyWith(
      baseHappiness: null == baseHappiness
          ? _value.baseHappiness
          : baseHappiness // ignore: cast_nullable_to_non_nullable
              as int,
      captureRate: null == captureRate
          ? _value.captureRate
          : captureRate // ignore: cast_nullable_to_non_nullable
              as int,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      eggGroups: null == eggGroups
          ? _value.eggGroups
          : eggGroups // ignore: cast_nullable_to_non_nullable
              as List<EggGroups>,
      evolutionChain: null == evolutionChain
          ? _value.evolutionChain
          : evolutionChain // ignore: cast_nullable_to_non_nullable
              as EvolutionChain,
      evolvesFromSpecies: freezed == evolvesFromSpecies
          ? _value.evolvesFromSpecies
          : evolvesFromSpecies // ignore: cast_nullable_to_non_nullable
              as String?,
      flavorTextEntries: null == flavorTextEntries
          ? _value.flavorTextEntries
          : flavorTextEntries // ignore: cast_nullable_to_non_nullable
              as List<FlavorTextEntries>,
      formDescriptions: null == formDescriptions
          ? _value.formDescriptions
          : formDescriptions // ignore: cast_nullable_to_non_nullable
              as List<FormDescriptions>,
      formsSwitchable: null == formsSwitchable
          ? _value.formsSwitchable
          : formsSwitchable // ignore: cast_nullable_to_non_nullable
              as bool,
      genderRate: null == genderRate
          ? _value.genderRate
          : genderRate // ignore: cast_nullable_to_non_nullable
              as int,
      genera: null == genera
          ? _value.genera
          : genera // ignore: cast_nullable_to_non_nullable
              as List<Genera>,
      generation: null == generation
          ? _value.generation
          : generation // ignore: cast_nullable_to_non_nullable
              as Generation,
      growthRate: null == growthRate
          ? _value.growthRate
          : growthRate // ignore: cast_nullable_to_non_nullable
              as GrowthRate,
      habitat: null == habitat
          ? _value.habitat
          : habitat // ignore: cast_nullable_to_non_nullable
              as Habitat,
      hasGenderDifferences: null == hasGenderDifferences
          ? _value.hasGenderDifferences
          : hasGenderDifferences // ignore: cast_nullable_to_non_nullable
              as bool,
      hatchCounter: null == hatchCounter
          ? _value.hatchCounter
          : hatchCounter // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      isBaby: null == isBaby
          ? _value.isBaby
          : isBaby // ignore: cast_nullable_to_non_nullable
              as bool,
      isLegendary: null == isLegendary
          ? _value.isLegendary
          : isLegendary // ignore: cast_nullable_to_non_nullable
              as bool,
      isMythical: null == isMythical
          ? _value.isMythical
          : isMythical // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      names: null == names
          ? _value.names
          : names // ignore: cast_nullable_to_non_nullable
              as List<Names>,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as int,
      palParkEncounters: null == palParkEncounters
          ? _value.palParkEncounters
          : palParkEncounters // ignore: cast_nullable_to_non_nullable
              as List<PalParkEncounters>,
      pokedexNumbers: null == pokedexNumbers
          ? _value.pokedexNumbers
          : pokedexNumbers // ignore: cast_nullable_to_non_nullable
              as List<PokedexNumbers>,
      shape: null == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as Shape,
      varieties: null == varieties
          ? _value.varieties
          : varieties // ignore: cast_nullable_to_non_nullable
              as List<Varieties>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ColorCopyWith<$Res> get color {
    return $ColorCopyWith<$Res>(_value.color, (value) {
      return _then(_value.copyWith(color: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EvolutionChainCopyWith<$Res> get evolutionChain {
    return $EvolutionChainCopyWith<$Res>(_value.evolutionChain, (value) {
      return _then(_value.copyWith(evolutionChain: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenerationCopyWith<$Res> get generation {
    return $GenerationCopyWith<$Res>(_value.generation, (value) {
      return _then(_value.copyWith(generation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GrowthRateCopyWith<$Res> get growthRate {
    return $GrowthRateCopyWith<$Res>(_value.growthRate, (value) {
      return _then(_value.copyWith(growthRate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $HabitatCopyWith<$Res> get habitat {
    return $HabitatCopyWith<$Res>(_value.habitat, (value) {
      return _then(_value.copyWith(habitat: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ShapeCopyWith<$Res> get shape {
    return $ShapeCopyWith<$Res>(_value.shape, (value) {
      return _then(_value.copyWith(shape: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GetPokemonSpecieResponseImplCopyWith<$Res>
    implements $GetPokemonSpecieResponseCopyWith<$Res> {
  factory _$$GetPokemonSpecieResponseImplCopyWith(
          _$GetPokemonSpecieResponseImpl value,
          $Res Function(_$GetPokemonSpecieResponseImpl) then) =
      __$$GetPokemonSpecieResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int baseHappiness,
      int captureRate,
      Color color,
      List<EggGroups> eggGroups,
      EvolutionChain evolutionChain,
      String? evolvesFromSpecies,
      List<FlavorTextEntries> flavorTextEntries,
      List<FormDescriptions> formDescriptions,
      bool formsSwitchable,
      int genderRate,
      List<Genera> genera,
      Generation generation,
      GrowthRate growthRate,
      Habitat habitat,
      bool hasGenderDifferences,
      int hatchCounter,
      int id,
      bool isBaby,
      bool isLegendary,
      bool isMythical,
      String name,
      List<Names> names,
      int order,
      List<PalParkEncounters> palParkEncounters,
      List<PokedexNumbers> pokedexNumbers,
      Shape shape,
      List<Varieties> varieties});

  @override
  $ColorCopyWith<$Res> get color;
  @override
  $EvolutionChainCopyWith<$Res> get evolutionChain;
  @override
  $GenerationCopyWith<$Res> get generation;
  @override
  $GrowthRateCopyWith<$Res> get growthRate;
  @override
  $HabitatCopyWith<$Res> get habitat;
  @override
  $ShapeCopyWith<$Res> get shape;
}

/// @nodoc
class __$$GetPokemonSpecieResponseImplCopyWithImpl<$Res>
    extends _$GetPokemonSpecieResponseCopyWithImpl<$Res,
        _$GetPokemonSpecieResponseImpl>
    implements _$$GetPokemonSpecieResponseImplCopyWith<$Res> {
  __$$GetPokemonSpecieResponseImplCopyWithImpl(
      _$GetPokemonSpecieResponseImpl _value,
      $Res Function(_$GetPokemonSpecieResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? baseHappiness = null,
    Object? captureRate = null,
    Object? color = null,
    Object? eggGroups = null,
    Object? evolutionChain = null,
    Object? evolvesFromSpecies = freezed,
    Object? flavorTextEntries = null,
    Object? formDescriptions = null,
    Object? formsSwitchable = null,
    Object? genderRate = null,
    Object? genera = null,
    Object? generation = null,
    Object? growthRate = null,
    Object? habitat = null,
    Object? hasGenderDifferences = null,
    Object? hatchCounter = null,
    Object? id = null,
    Object? isBaby = null,
    Object? isLegendary = null,
    Object? isMythical = null,
    Object? name = null,
    Object? names = null,
    Object? order = null,
    Object? palParkEncounters = null,
    Object? pokedexNumbers = null,
    Object? shape = null,
    Object? varieties = null,
  }) {
    return _then(_$GetPokemonSpecieResponseImpl(
      baseHappiness: null == baseHappiness
          ? _value.baseHappiness
          : baseHappiness // ignore: cast_nullable_to_non_nullable
              as int,
      captureRate: null == captureRate
          ? _value.captureRate
          : captureRate // ignore: cast_nullable_to_non_nullable
              as int,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      eggGroups: null == eggGroups
          ? _value._eggGroups
          : eggGroups // ignore: cast_nullable_to_non_nullable
              as List<EggGroups>,
      evolutionChain: null == evolutionChain
          ? _value.evolutionChain
          : evolutionChain // ignore: cast_nullable_to_non_nullable
              as EvolutionChain,
      evolvesFromSpecies: freezed == evolvesFromSpecies
          ? _value.evolvesFromSpecies
          : evolvesFromSpecies // ignore: cast_nullable_to_non_nullable
              as String?,
      flavorTextEntries: null == flavorTextEntries
          ? _value._flavorTextEntries
          : flavorTextEntries // ignore: cast_nullable_to_non_nullable
              as List<FlavorTextEntries>,
      formDescriptions: null == formDescriptions
          ? _value._formDescriptions
          : formDescriptions // ignore: cast_nullable_to_non_nullable
              as List<FormDescriptions>,
      formsSwitchable: null == formsSwitchable
          ? _value.formsSwitchable
          : formsSwitchable // ignore: cast_nullable_to_non_nullable
              as bool,
      genderRate: null == genderRate
          ? _value.genderRate
          : genderRate // ignore: cast_nullable_to_non_nullable
              as int,
      genera: null == genera
          ? _value._genera
          : genera // ignore: cast_nullable_to_non_nullable
              as List<Genera>,
      generation: null == generation
          ? _value.generation
          : generation // ignore: cast_nullable_to_non_nullable
              as Generation,
      growthRate: null == growthRate
          ? _value.growthRate
          : growthRate // ignore: cast_nullable_to_non_nullable
              as GrowthRate,
      habitat: null == habitat
          ? _value.habitat
          : habitat // ignore: cast_nullable_to_non_nullable
              as Habitat,
      hasGenderDifferences: null == hasGenderDifferences
          ? _value.hasGenderDifferences
          : hasGenderDifferences // ignore: cast_nullable_to_non_nullable
              as bool,
      hatchCounter: null == hatchCounter
          ? _value.hatchCounter
          : hatchCounter // ignore: cast_nullable_to_non_nullable
              as int,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      isBaby: null == isBaby
          ? _value.isBaby
          : isBaby // ignore: cast_nullable_to_non_nullable
              as bool,
      isLegendary: null == isLegendary
          ? _value.isLegendary
          : isLegendary // ignore: cast_nullable_to_non_nullable
              as bool,
      isMythical: null == isMythical
          ? _value.isMythical
          : isMythical // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      names: null == names
          ? _value._names
          : names // ignore: cast_nullable_to_non_nullable
              as List<Names>,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as int,
      palParkEncounters: null == palParkEncounters
          ? _value._palParkEncounters
          : palParkEncounters // ignore: cast_nullable_to_non_nullable
              as List<PalParkEncounters>,
      pokedexNumbers: null == pokedexNumbers
          ? _value._pokedexNumbers
          : pokedexNumbers // ignore: cast_nullable_to_non_nullable
              as List<PokedexNumbers>,
      shape: null == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as Shape,
      varieties: null == varieties
          ? _value._varieties
          : varieties // ignore: cast_nullable_to_non_nullable
              as List<Varieties>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GetPokemonSpecieResponseImpl
    with DiagnosticableTreeMixin
    implements _GetPokemonSpecieResponse {
  const _$GetPokemonSpecieResponseImpl(
      {required this.baseHappiness,
      required this.captureRate,
      required this.color,
      required final List<EggGroups> eggGroups,
      required this.evolutionChain,
      required this.evolvesFromSpecies,
      required final List<FlavorTextEntries> flavorTextEntries,
      required final List<FormDescriptions> formDescriptions,
      required this.formsSwitchable,
      required this.genderRate,
      required final List<Genera> genera,
      required this.generation,
      required this.growthRate,
      required this.habitat,
      required this.hasGenderDifferences,
      required this.hatchCounter,
      required this.id,
      required this.isBaby,
      required this.isLegendary,
      required this.isMythical,
      required this.name,
      required final List<Names> names,
      required this.order,
      required final List<PalParkEncounters> palParkEncounters,
      required final List<PokedexNumbers> pokedexNumbers,
      required this.shape,
      required final List<Varieties> varieties})
      : _eggGroups = eggGroups,
        _flavorTextEntries = flavorTextEntries,
        _formDescriptions = formDescriptions,
        _genera = genera,
        _names = names,
        _palParkEncounters = palParkEncounters,
        _pokedexNumbers = pokedexNumbers,
        _varieties = varieties;

  factory _$GetPokemonSpecieResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$GetPokemonSpecieResponseImplFromJson(json);

  @override
  final int baseHappiness;
  @override
  final int captureRate;
  @override
  final Color color;
  final List<EggGroups> _eggGroups;
  @override
  List<EggGroups> get eggGroups {
    if (_eggGroups is EqualUnmodifiableListView) return _eggGroups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_eggGroups);
  }

  @override
  final EvolutionChain evolutionChain;
  @override
  final String? evolvesFromSpecies;
  final List<FlavorTextEntries> _flavorTextEntries;
  @override
  List<FlavorTextEntries> get flavorTextEntries {
    if (_flavorTextEntries is EqualUnmodifiableListView)
      return _flavorTextEntries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_flavorTextEntries);
  }

  final List<FormDescriptions> _formDescriptions;
  @override
  List<FormDescriptions> get formDescriptions {
    if (_formDescriptions is EqualUnmodifiableListView)
      return _formDescriptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_formDescriptions);
  }

  @override
  final bool formsSwitchable;
  @override
  final int genderRate;
  final List<Genera> _genera;
  @override
  List<Genera> get genera {
    if (_genera is EqualUnmodifiableListView) return _genera;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_genera);
  }

  @override
  final Generation generation;
  @override
  final GrowthRate growthRate;
  @override
  final Habitat habitat;
  @override
  final bool hasGenderDifferences;
  @override
  final int hatchCounter;
  @override
  final int id;
  @override
  final bool isBaby;
  @override
  final bool isLegendary;
  @override
  final bool isMythical;
  @override
  final String name;
  final List<Names> _names;
  @override
  List<Names> get names {
    if (_names is EqualUnmodifiableListView) return _names;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_names);
  }

  @override
  final int order;
  final List<PalParkEncounters> _palParkEncounters;
  @override
  List<PalParkEncounters> get palParkEncounters {
    if (_palParkEncounters is EqualUnmodifiableListView)
      return _palParkEncounters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_palParkEncounters);
  }

  final List<PokedexNumbers> _pokedexNumbers;
  @override
  List<PokedexNumbers> get pokedexNumbers {
    if (_pokedexNumbers is EqualUnmodifiableListView) return _pokedexNumbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pokedexNumbers);
  }

  @override
  final Shape shape;
  final List<Varieties> _varieties;
  @override
  List<Varieties> get varieties {
    if (_varieties is EqualUnmodifiableListView) return _varieties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_varieties);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GetPokemonSpecieResponse(baseHappiness: $baseHappiness, captureRate: $captureRate, color: $color, eggGroups: $eggGroups, evolutionChain: $evolutionChain, evolvesFromSpecies: $evolvesFromSpecies, flavorTextEntries: $flavorTextEntries, formDescriptions: $formDescriptions, formsSwitchable: $formsSwitchable, genderRate: $genderRate, genera: $genera, generation: $generation, growthRate: $growthRate, habitat: $habitat, hasGenderDifferences: $hasGenderDifferences, hatchCounter: $hatchCounter, id: $id, isBaby: $isBaby, isLegendary: $isLegendary, isMythical: $isMythical, name: $name, names: $names, order: $order, palParkEncounters: $palParkEncounters, pokedexNumbers: $pokedexNumbers, shape: $shape, varieties: $varieties)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GetPokemonSpecieResponse'))
      ..add(DiagnosticsProperty('baseHappiness', baseHappiness))
      ..add(DiagnosticsProperty('captureRate', captureRate))
      ..add(DiagnosticsProperty('color', color))
      ..add(DiagnosticsProperty('eggGroups', eggGroups))
      ..add(DiagnosticsProperty('evolutionChain', evolutionChain))
      ..add(DiagnosticsProperty('evolvesFromSpecies', evolvesFromSpecies))
      ..add(DiagnosticsProperty('flavorTextEntries', flavorTextEntries))
      ..add(DiagnosticsProperty('formDescriptions', formDescriptions))
      ..add(DiagnosticsProperty('formsSwitchable', formsSwitchable))
      ..add(DiagnosticsProperty('genderRate', genderRate))
      ..add(DiagnosticsProperty('genera', genera))
      ..add(DiagnosticsProperty('generation', generation))
      ..add(DiagnosticsProperty('growthRate', growthRate))
      ..add(DiagnosticsProperty('habitat', habitat))
      ..add(DiagnosticsProperty('hasGenderDifferences', hasGenderDifferences))
      ..add(DiagnosticsProperty('hatchCounter', hatchCounter))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('isBaby', isBaby))
      ..add(DiagnosticsProperty('isLegendary', isLegendary))
      ..add(DiagnosticsProperty('isMythical', isMythical))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('names', names))
      ..add(DiagnosticsProperty('order', order))
      ..add(DiagnosticsProperty('palParkEncounters', palParkEncounters))
      ..add(DiagnosticsProperty('pokedexNumbers', pokedexNumbers))
      ..add(DiagnosticsProperty('shape', shape))
      ..add(DiagnosticsProperty('varieties', varieties));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetPokemonSpecieResponseImpl &&
            (identical(other.baseHappiness, baseHappiness) ||
                other.baseHappiness == baseHappiness) &&
            (identical(other.captureRate, captureRate) ||
                other.captureRate == captureRate) &&
            (identical(other.color, color) || other.color == color) &&
            const DeepCollectionEquality()
                .equals(other._eggGroups, _eggGroups) &&
            (identical(other.evolutionChain, evolutionChain) ||
                other.evolutionChain == evolutionChain) &&
            (identical(other.evolvesFromSpecies, evolvesFromSpecies) ||
                other.evolvesFromSpecies == evolvesFromSpecies) &&
            const DeepCollectionEquality()
                .equals(other._flavorTextEntries, _flavorTextEntries) &&
            const DeepCollectionEquality()
                .equals(other._formDescriptions, _formDescriptions) &&
            (identical(other.formsSwitchable, formsSwitchable) ||
                other.formsSwitchable == formsSwitchable) &&
            (identical(other.genderRate, genderRate) ||
                other.genderRate == genderRate) &&
            const DeepCollectionEquality().equals(other._genera, _genera) &&
            (identical(other.generation, generation) ||
                other.generation == generation) &&
            (identical(other.growthRate, growthRate) ||
                other.growthRate == growthRate) &&
            (identical(other.habitat, habitat) || other.habitat == habitat) &&
            (identical(other.hasGenderDifferences, hasGenderDifferences) ||
                other.hasGenderDifferences == hasGenderDifferences) &&
            (identical(other.hatchCounter, hatchCounter) ||
                other.hatchCounter == hatchCounter) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.isBaby, isBaby) || other.isBaby == isBaby) &&
            (identical(other.isLegendary, isLegendary) ||
                other.isLegendary == isLegendary) &&
            (identical(other.isMythical, isMythical) ||
                other.isMythical == isMythical) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._names, _names) &&
            (identical(other.order, order) || other.order == order) &&
            const DeepCollectionEquality()
                .equals(other._palParkEncounters, _palParkEncounters) &&
            const DeepCollectionEquality()
                .equals(other._pokedexNumbers, _pokedexNumbers) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            const DeepCollectionEquality()
                .equals(other._varieties, _varieties));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        baseHappiness,
        captureRate,
        color,
        const DeepCollectionEquality().hash(_eggGroups),
        evolutionChain,
        evolvesFromSpecies,
        const DeepCollectionEquality().hash(_flavorTextEntries),
        const DeepCollectionEquality().hash(_formDescriptions),
        formsSwitchable,
        genderRate,
        const DeepCollectionEquality().hash(_genera),
        generation,
        growthRate,
        habitat,
        hasGenderDifferences,
        hatchCounter,
        id,
        isBaby,
        isLegendary,
        isMythical,
        name,
        const DeepCollectionEquality().hash(_names),
        order,
        const DeepCollectionEquality().hash(_palParkEncounters),
        const DeepCollectionEquality().hash(_pokedexNumbers),
        shape,
        const DeepCollectionEquality().hash(_varieties)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetPokemonSpecieResponseImplCopyWith<_$GetPokemonSpecieResponseImpl>
      get copyWith => __$$GetPokemonSpecieResponseImplCopyWithImpl<
          _$GetPokemonSpecieResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GetPokemonSpecieResponseImplToJson(
      this,
    );
  }
}

abstract class _GetPokemonSpecieResponse implements GetPokemonSpecieResponse {
  const factory _GetPokemonSpecieResponse(
          {required final int baseHappiness,
          required final int captureRate,
          required final Color color,
          required final List<EggGroups> eggGroups,
          required final EvolutionChain evolutionChain,
          required final String? evolvesFromSpecies,
          required final List<FlavorTextEntries> flavorTextEntries,
          required final List<FormDescriptions> formDescriptions,
          required final bool formsSwitchable,
          required final int genderRate,
          required final List<Genera> genera,
          required final Generation generation,
          required final GrowthRate growthRate,
          required final Habitat habitat,
          required final bool hasGenderDifferences,
          required final int hatchCounter,
          required final int id,
          required final bool isBaby,
          required final bool isLegendary,
          required final bool isMythical,
          required final String name,
          required final List<Names> names,
          required final int order,
          required final List<PalParkEncounters> palParkEncounters,
          required final List<PokedexNumbers> pokedexNumbers,
          required final Shape shape,
          required final List<Varieties> varieties}) =
      _$GetPokemonSpecieResponseImpl;

  factory _GetPokemonSpecieResponse.fromJson(Map<String, dynamic> json) =
      _$GetPokemonSpecieResponseImpl.fromJson;

  @override
  int get baseHappiness;
  @override
  int get captureRate;
  @override
  Color get color;
  @override
  List<EggGroups> get eggGroups;
  @override
  EvolutionChain get evolutionChain;
  @override
  String? get evolvesFromSpecies;
  @override
  List<FlavorTextEntries> get flavorTextEntries;
  @override
  List<FormDescriptions> get formDescriptions;
  @override
  bool get formsSwitchable;
  @override
  int get genderRate;
  @override
  List<Genera> get genera;
  @override
  Generation get generation;
  @override
  GrowthRate get growthRate;
  @override
  Habitat get habitat;
  @override
  bool get hasGenderDifferences;
  @override
  int get hatchCounter;
  @override
  int get id;
  @override
  bool get isBaby;
  @override
  bool get isLegendary;
  @override
  bool get isMythical;
  @override
  String get name;
  @override
  List<Names> get names;
  @override
  int get order;
  @override
  List<PalParkEncounters> get palParkEncounters;
  @override
  List<PokedexNumbers> get pokedexNumbers;
  @override
  Shape get shape;
  @override
  List<Varieties> get varieties;
  @override
  @JsonKey(ignore: true)
  _$$GetPokemonSpecieResponseImplCopyWith<_$GetPokemonSpecieResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Color _$ColorFromJson(Map<String, dynamic> json) {
  return _Color.fromJson(json);
}

/// @nodoc
mixin _$Color {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ColorCopyWith<Color> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ColorCopyWith<$Res> {
  factory $ColorCopyWith(Color value, $Res Function(Color) then) =
      _$ColorCopyWithImpl<$Res, Color>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$ColorCopyWithImpl<$Res, $Val extends Color>
    implements $ColorCopyWith<$Res> {
  _$ColorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ColorImplCopyWith<$Res> implements $ColorCopyWith<$Res> {
  factory _$$ColorImplCopyWith(
          _$ColorImpl value, $Res Function(_$ColorImpl) then) =
      __$$ColorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$ColorImplCopyWithImpl<$Res>
    extends _$ColorCopyWithImpl<$Res, _$ColorImpl>
    implements _$$ColorImplCopyWith<$Res> {
  __$$ColorImplCopyWithImpl(
      _$ColorImpl _value, $Res Function(_$ColorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$ColorImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ColorImpl with DiagnosticableTreeMixin implements _Color {
  const _$ColorImpl({required this.name, required this.url});

  factory _$ColorImpl.fromJson(Map<String, dynamic> json) =>
      _$$ColorImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Color(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Color'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ColorImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ColorImplCopyWith<_$ColorImpl> get copyWith =>
      __$$ColorImplCopyWithImpl<_$ColorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ColorImplToJson(
      this,
    );
  }
}

abstract class _Color implements Color {
  const factory _Color(
      {required final String name, required final String url}) = _$ColorImpl;

  factory _Color.fromJson(Map<String, dynamic> json) = _$ColorImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$ColorImplCopyWith<_$ColorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EggGroups _$EggGroupsFromJson(Map<String, dynamic> json) {
  return _EggGroups.fromJson(json);
}

/// @nodoc
mixin _$EggGroups {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EggGroupsCopyWith<EggGroups> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EggGroupsCopyWith<$Res> {
  factory $EggGroupsCopyWith(EggGroups value, $Res Function(EggGroups) then) =
      _$EggGroupsCopyWithImpl<$Res, EggGroups>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$EggGroupsCopyWithImpl<$Res, $Val extends EggGroups>
    implements $EggGroupsCopyWith<$Res> {
  _$EggGroupsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EggGroupsImplCopyWith<$Res>
    implements $EggGroupsCopyWith<$Res> {
  factory _$$EggGroupsImplCopyWith(
          _$EggGroupsImpl value, $Res Function(_$EggGroupsImpl) then) =
      __$$EggGroupsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$EggGroupsImplCopyWithImpl<$Res>
    extends _$EggGroupsCopyWithImpl<$Res, _$EggGroupsImpl>
    implements _$$EggGroupsImplCopyWith<$Res> {
  __$$EggGroupsImplCopyWithImpl(
      _$EggGroupsImpl _value, $Res Function(_$EggGroupsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$EggGroupsImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EggGroupsImpl with DiagnosticableTreeMixin implements _EggGroups {
  const _$EggGroupsImpl({required this.name, required this.url});

  factory _$EggGroupsImpl.fromJson(Map<String, dynamic> json) =>
      _$$EggGroupsImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'EggGroups(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'EggGroups'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EggGroupsImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EggGroupsImplCopyWith<_$EggGroupsImpl> get copyWith =>
      __$$EggGroupsImplCopyWithImpl<_$EggGroupsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EggGroupsImplToJson(
      this,
    );
  }
}

abstract class _EggGroups implements EggGroups {
  const factory _EggGroups(
      {required final String name,
      required final String url}) = _$EggGroupsImpl;

  factory _EggGroups.fromJson(Map<String, dynamic> json) =
      _$EggGroupsImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$EggGroupsImplCopyWith<_$EggGroupsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EvolutionChain _$EvolutionChainFromJson(Map<String, dynamic> json) {
  return _EvolutionChain.fromJson(json);
}

/// @nodoc
mixin _$EvolutionChain {
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EvolutionChainCopyWith<EvolutionChain> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EvolutionChainCopyWith<$Res> {
  factory $EvolutionChainCopyWith(
          EvolutionChain value, $Res Function(EvolutionChain) then) =
      _$EvolutionChainCopyWithImpl<$Res, EvolutionChain>;
  @useResult
  $Res call({String url});
}

/// @nodoc
class _$EvolutionChainCopyWithImpl<$Res, $Val extends EvolutionChain>
    implements $EvolutionChainCopyWith<$Res> {
  _$EvolutionChainCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EvolutionChainImplCopyWith<$Res>
    implements $EvolutionChainCopyWith<$Res> {
  factory _$$EvolutionChainImplCopyWith(_$EvolutionChainImpl value,
          $Res Function(_$EvolutionChainImpl) then) =
      __$$EvolutionChainImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url});
}

/// @nodoc
class __$$EvolutionChainImplCopyWithImpl<$Res>
    extends _$EvolutionChainCopyWithImpl<$Res, _$EvolutionChainImpl>
    implements _$$EvolutionChainImplCopyWith<$Res> {
  __$$EvolutionChainImplCopyWithImpl(
      _$EvolutionChainImpl _value, $Res Function(_$EvolutionChainImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
  }) {
    return _then(_$EvolutionChainImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EvolutionChainImpl
    with DiagnosticableTreeMixin
    implements _EvolutionChain {
  const _$EvolutionChainImpl({required this.url});

  factory _$EvolutionChainImpl.fromJson(Map<String, dynamic> json) =>
      _$$EvolutionChainImplFromJson(json);

  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'EvolutionChain(url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'EvolutionChain'))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EvolutionChainImpl &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EvolutionChainImplCopyWith<_$EvolutionChainImpl> get copyWith =>
      __$$EvolutionChainImplCopyWithImpl<_$EvolutionChainImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EvolutionChainImplToJson(
      this,
    );
  }
}

abstract class _EvolutionChain implements EvolutionChain {
  const factory _EvolutionChain({required final String url}) =
      _$EvolutionChainImpl;

  factory _EvolutionChain.fromJson(Map<String, dynamic> json) =
      _$EvolutionChainImpl.fromJson;

  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$EvolutionChainImplCopyWith<_$EvolutionChainImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FlavorTextEntries _$FlavorTextEntriesFromJson(Map<String, dynamic> json) {
  return _FlavorTextEntries.fromJson(json);
}

/// @nodoc
mixin _$FlavorTextEntries {
  String get flavorText => throw _privateConstructorUsedError;
  Language get language => throw _privateConstructorUsedError;
  Version get version => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FlavorTextEntriesCopyWith<FlavorTextEntries> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FlavorTextEntriesCopyWith<$Res> {
  factory $FlavorTextEntriesCopyWith(
          FlavorTextEntries value, $Res Function(FlavorTextEntries) then) =
      _$FlavorTextEntriesCopyWithImpl<$Res, FlavorTextEntries>;
  @useResult
  $Res call({String flavorText, Language language, Version version});

  $LanguageCopyWith<$Res> get language;
  $VersionCopyWith<$Res> get version;
}

/// @nodoc
class _$FlavorTextEntriesCopyWithImpl<$Res, $Val extends FlavorTextEntries>
    implements $FlavorTextEntriesCopyWith<$Res> {
  _$FlavorTextEntriesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flavorText = null,
    Object? language = null,
    Object? version = null,
  }) {
    return _then(_value.copyWith(
      flavorText: null == flavorText
          ? _value.flavorText
          : flavorText // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as Version,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res> get language {
    return $LanguageCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VersionCopyWith<$Res> get version {
    return $VersionCopyWith<$Res>(_value.version, (value) {
      return _then(_value.copyWith(version: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FlavorTextEntriesImplCopyWith<$Res>
    implements $FlavorTextEntriesCopyWith<$Res> {
  factory _$$FlavorTextEntriesImplCopyWith(_$FlavorTextEntriesImpl value,
          $Res Function(_$FlavorTextEntriesImpl) then) =
      __$$FlavorTextEntriesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String flavorText, Language language, Version version});

  @override
  $LanguageCopyWith<$Res> get language;
  @override
  $VersionCopyWith<$Res> get version;
}

/// @nodoc
class __$$FlavorTextEntriesImplCopyWithImpl<$Res>
    extends _$FlavorTextEntriesCopyWithImpl<$Res, _$FlavorTextEntriesImpl>
    implements _$$FlavorTextEntriesImplCopyWith<$Res> {
  __$$FlavorTextEntriesImplCopyWithImpl(_$FlavorTextEntriesImpl _value,
      $Res Function(_$FlavorTextEntriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? flavorText = null,
    Object? language = null,
    Object? version = null,
  }) {
    return _then(_$FlavorTextEntriesImpl(
      flavorText: null == flavorText
          ? _value.flavorText
          : flavorText // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as Version,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FlavorTextEntriesImpl
    with DiagnosticableTreeMixin
    implements _FlavorTextEntries {
  const _$FlavorTextEntriesImpl(
      {required this.flavorText,
      required this.language,
      required this.version});

  factory _$FlavorTextEntriesImpl.fromJson(Map<String, dynamic> json) =>
      _$$FlavorTextEntriesImplFromJson(json);

  @override
  final String flavorText;
  @override
  final Language language;
  @override
  final Version version;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FlavorTextEntries(flavorText: $flavorText, language: $language, version: $version)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FlavorTextEntries'))
      ..add(DiagnosticsProperty('flavorText', flavorText))
      ..add(DiagnosticsProperty('language', language))
      ..add(DiagnosticsProperty('version', version));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FlavorTextEntriesImpl &&
            (identical(other.flavorText, flavorText) ||
                other.flavorText == flavorText) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.version, version) || other.version == version));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, flavorText, language, version);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FlavorTextEntriesImplCopyWith<_$FlavorTextEntriesImpl> get copyWith =>
      __$$FlavorTextEntriesImplCopyWithImpl<_$FlavorTextEntriesImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FlavorTextEntriesImplToJson(
      this,
    );
  }
}

abstract class _FlavorTextEntries implements FlavorTextEntries {
  const factory _FlavorTextEntries(
      {required final String flavorText,
      required final Language language,
      required final Version version}) = _$FlavorTextEntriesImpl;

  factory _FlavorTextEntries.fromJson(Map<String, dynamic> json) =
      _$FlavorTextEntriesImpl.fromJson;

  @override
  String get flavorText;
  @override
  Language get language;
  @override
  Version get version;
  @override
  @JsonKey(ignore: true)
  _$$FlavorTextEntriesImplCopyWith<_$FlavorTextEntriesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Language _$LanguageFromJson(Map<String, dynamic> json) {
  return _Language.fromJson(json);
}

/// @nodoc
mixin _$Language {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LanguageCopyWith<Language> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LanguageCopyWith<$Res> {
  factory $LanguageCopyWith(Language value, $Res Function(Language) then) =
      _$LanguageCopyWithImpl<$Res, Language>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$LanguageCopyWithImpl<$Res, $Val extends Language>
    implements $LanguageCopyWith<$Res> {
  _$LanguageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LanguageImplCopyWith<$Res>
    implements $LanguageCopyWith<$Res> {
  factory _$$LanguageImplCopyWith(
          _$LanguageImpl value, $Res Function(_$LanguageImpl) then) =
      __$$LanguageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$LanguageImplCopyWithImpl<$Res>
    extends _$LanguageCopyWithImpl<$Res, _$LanguageImpl>
    implements _$$LanguageImplCopyWith<$Res> {
  __$$LanguageImplCopyWithImpl(
      _$LanguageImpl _value, $Res Function(_$LanguageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$LanguageImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LanguageImpl with DiagnosticableTreeMixin implements _Language {
  const _$LanguageImpl({required this.name, required this.url});

  factory _$LanguageImpl.fromJson(Map<String, dynamic> json) =>
      _$$LanguageImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Language(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Language'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LanguageImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LanguageImplCopyWith<_$LanguageImpl> get copyWith =>
      __$$LanguageImplCopyWithImpl<_$LanguageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LanguageImplToJson(
      this,
    );
  }
}

abstract class _Language implements Language {
  const factory _Language(
      {required final String name, required final String url}) = _$LanguageImpl;

  factory _Language.fromJson(Map<String, dynamic> json) =
      _$LanguageImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$LanguageImplCopyWith<_$LanguageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Version _$VersionFromJson(Map<String, dynamic> json) {
  return _Version.fromJson(json);
}

/// @nodoc
mixin _$Version {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VersionCopyWith<Version> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VersionCopyWith<$Res> {
  factory $VersionCopyWith(Version value, $Res Function(Version) then) =
      _$VersionCopyWithImpl<$Res, Version>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$VersionCopyWithImpl<$Res, $Val extends Version>
    implements $VersionCopyWith<$Res> {
  _$VersionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VersionImplCopyWith<$Res> implements $VersionCopyWith<$Res> {
  factory _$$VersionImplCopyWith(
          _$VersionImpl value, $Res Function(_$VersionImpl) then) =
      __$$VersionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$VersionImplCopyWithImpl<$Res>
    extends _$VersionCopyWithImpl<$Res, _$VersionImpl>
    implements _$$VersionImplCopyWith<$Res> {
  __$$VersionImplCopyWithImpl(
      _$VersionImpl _value, $Res Function(_$VersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$VersionImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VersionImpl with DiagnosticableTreeMixin implements _Version {
  const _$VersionImpl({required this.name, required this.url});

  factory _$VersionImpl.fromJson(Map<String, dynamic> json) =>
      _$$VersionImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Version(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Version'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VersionImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VersionImplCopyWith<_$VersionImpl> get copyWith =>
      __$$VersionImplCopyWithImpl<_$VersionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VersionImplToJson(
      this,
    );
  }
}

abstract class _Version implements Version {
  const factory _Version(
      {required final String name, required final String url}) = _$VersionImpl;

  factory _Version.fromJson(Map<String, dynamic> json) = _$VersionImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$VersionImplCopyWith<_$VersionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FormDescriptions _$FormDescriptionsFromJson(Map<String, dynamic> json) {
  return _FormDescriptions.fromJson(json);
}

/// @nodoc
mixin _$FormDescriptions {
  String get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FormDescriptionsCopyWith<FormDescriptions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormDescriptionsCopyWith<$Res> {
  factory $FormDescriptionsCopyWith(
          FormDescriptions value, $Res Function(FormDescriptions) then) =
      _$FormDescriptionsCopyWithImpl<$Res, FormDescriptions>;
  @useResult
  $Res call({String description});
}

/// @nodoc
class _$FormDescriptionsCopyWithImpl<$Res, $Val extends FormDescriptions>
    implements $FormDescriptionsCopyWith<$Res> {
  _$FormDescriptionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
  }) {
    return _then(_value.copyWith(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FormDescriptionsImplCopyWith<$Res>
    implements $FormDescriptionsCopyWith<$Res> {
  factory _$$FormDescriptionsImplCopyWith(_$FormDescriptionsImpl value,
          $Res Function(_$FormDescriptionsImpl) then) =
      __$$FormDescriptionsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String description});
}

/// @nodoc
class __$$FormDescriptionsImplCopyWithImpl<$Res>
    extends _$FormDescriptionsCopyWithImpl<$Res, _$FormDescriptionsImpl>
    implements _$$FormDescriptionsImplCopyWith<$Res> {
  __$$FormDescriptionsImplCopyWithImpl(_$FormDescriptionsImpl _value,
      $Res Function(_$FormDescriptionsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
  }) {
    return _then(_$FormDescriptionsImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FormDescriptionsImpl
    with DiagnosticableTreeMixin
    implements _FormDescriptions {
  const _$FormDescriptionsImpl({required this.description});

  factory _$FormDescriptionsImpl.fromJson(Map<String, dynamic> json) =>
      _$$FormDescriptionsImplFromJson(json);

  @override
  final String description;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'FormDescriptions(description: $description)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'FormDescriptions'))
      ..add(DiagnosticsProperty('description', description));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormDescriptionsImpl &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormDescriptionsImplCopyWith<_$FormDescriptionsImpl> get copyWith =>
      __$$FormDescriptionsImplCopyWithImpl<_$FormDescriptionsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FormDescriptionsImplToJson(
      this,
    );
  }
}

abstract class _FormDescriptions implements FormDescriptions {
  const factory _FormDescriptions({required final String description}) =
      _$FormDescriptionsImpl;

  factory _FormDescriptions.fromJson(Map<String, dynamic> json) =
      _$FormDescriptionsImpl.fromJson;

  @override
  String get description;
  @override
  @JsonKey(ignore: true)
  _$$FormDescriptionsImplCopyWith<_$FormDescriptionsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Genera _$GeneraFromJson(Map<String, dynamic> json) {
  return _Genera.fromJson(json);
}

/// @nodoc
mixin _$Genera {
  String get genus => throw _privateConstructorUsedError;
  Language get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeneraCopyWith<Genera> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneraCopyWith<$Res> {
  factory $GeneraCopyWith(Genera value, $Res Function(Genera) then) =
      _$GeneraCopyWithImpl<$Res, Genera>;
  @useResult
  $Res call({String genus, Language language});

  $LanguageCopyWith<$Res> get language;
}

/// @nodoc
class _$GeneraCopyWithImpl<$Res, $Val extends Genera>
    implements $GeneraCopyWith<$Res> {
  _$GeneraCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? genus = null,
    Object? language = null,
  }) {
    return _then(_value.copyWith(
      genus: null == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res> get language {
    return $LanguageCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GeneraImplCopyWith<$Res> implements $GeneraCopyWith<$Res> {
  factory _$$GeneraImplCopyWith(
          _$GeneraImpl value, $Res Function(_$GeneraImpl) then) =
      __$$GeneraImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String genus, Language language});

  @override
  $LanguageCopyWith<$Res> get language;
}

/// @nodoc
class __$$GeneraImplCopyWithImpl<$Res>
    extends _$GeneraCopyWithImpl<$Res, _$GeneraImpl>
    implements _$$GeneraImplCopyWith<$Res> {
  __$$GeneraImplCopyWithImpl(
      _$GeneraImpl _value, $Res Function(_$GeneraImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? genus = null,
    Object? language = null,
  }) {
    return _then(_$GeneraImpl(
      genus: null == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GeneraImpl with DiagnosticableTreeMixin implements _Genera {
  const _$GeneraImpl({required this.genus, required this.language});

  factory _$GeneraImpl.fromJson(Map<String, dynamic> json) =>
      _$$GeneraImplFromJson(json);

  @override
  final String genus;
  @override
  final Language language;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Genera(genus: $genus, language: $language)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Genera'))
      ..add(DiagnosticsProperty('genus', genus))
      ..add(DiagnosticsProperty('language', language));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GeneraImpl &&
            (identical(other.genus, genus) || other.genus == genus) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, genus, language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GeneraImplCopyWith<_$GeneraImpl> get copyWith =>
      __$$GeneraImplCopyWithImpl<_$GeneraImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GeneraImplToJson(
      this,
    );
  }
}

abstract class _Genera implements Genera {
  const factory _Genera(
      {required final String genus,
      required final Language language}) = _$GeneraImpl;

  factory _Genera.fromJson(Map<String, dynamic> json) = _$GeneraImpl.fromJson;

  @override
  String get genus;
  @override
  Language get language;
  @override
  @JsonKey(ignore: true)
  _$$GeneraImplCopyWith<_$GeneraImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Generation _$GenerationFromJson(Map<String, dynamic> json) {
  return _Generation.fromJson(json);
}

/// @nodoc
mixin _$Generation {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenerationCopyWith<Generation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenerationCopyWith<$Res> {
  factory $GenerationCopyWith(
          Generation value, $Res Function(Generation) then) =
      _$GenerationCopyWithImpl<$Res, Generation>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$GenerationCopyWithImpl<$Res, $Val extends Generation>
    implements $GenerationCopyWith<$Res> {
  _$GenerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GenerationImplCopyWith<$Res>
    implements $GenerationCopyWith<$Res> {
  factory _$$GenerationImplCopyWith(
          _$GenerationImpl value, $Res Function(_$GenerationImpl) then) =
      __$$GenerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$GenerationImplCopyWithImpl<$Res>
    extends _$GenerationCopyWithImpl<$Res, _$GenerationImpl>
    implements _$$GenerationImplCopyWith<$Res> {
  __$$GenerationImplCopyWithImpl(
      _$GenerationImpl _value, $Res Function(_$GenerationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$GenerationImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GenerationImpl with DiagnosticableTreeMixin implements _Generation {
  const _$GenerationImpl({required this.name, required this.url});

  factory _$GenerationImpl.fromJson(Map<String, dynamic> json) =>
      _$$GenerationImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Generation(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Generation'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenerationImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GenerationImplCopyWith<_$GenerationImpl> get copyWith =>
      __$$GenerationImplCopyWithImpl<_$GenerationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GenerationImplToJson(
      this,
    );
  }
}

abstract class _Generation implements Generation {
  const factory _Generation(
      {required final String name,
      required final String url}) = _$GenerationImpl;

  factory _Generation.fromJson(Map<String, dynamic> json) =
      _$GenerationImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$GenerationImplCopyWith<_$GenerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

GrowthRate _$GrowthRateFromJson(Map<String, dynamic> json) {
  return _GrowthRate.fromJson(json);
}

/// @nodoc
mixin _$GrowthRate {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GrowthRateCopyWith<GrowthRate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GrowthRateCopyWith<$Res> {
  factory $GrowthRateCopyWith(
          GrowthRate value, $Res Function(GrowthRate) then) =
      _$GrowthRateCopyWithImpl<$Res, GrowthRate>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$GrowthRateCopyWithImpl<$Res, $Val extends GrowthRate>
    implements $GrowthRateCopyWith<$Res> {
  _$GrowthRateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GrowthRateImplCopyWith<$Res>
    implements $GrowthRateCopyWith<$Res> {
  factory _$$GrowthRateImplCopyWith(
          _$GrowthRateImpl value, $Res Function(_$GrowthRateImpl) then) =
      __$$GrowthRateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$GrowthRateImplCopyWithImpl<$Res>
    extends _$GrowthRateCopyWithImpl<$Res, _$GrowthRateImpl>
    implements _$$GrowthRateImplCopyWith<$Res> {
  __$$GrowthRateImplCopyWithImpl(
      _$GrowthRateImpl _value, $Res Function(_$GrowthRateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$GrowthRateImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GrowthRateImpl with DiagnosticableTreeMixin implements _GrowthRate {
  const _$GrowthRateImpl({required this.name, required this.url});

  factory _$GrowthRateImpl.fromJson(Map<String, dynamic> json) =>
      _$$GrowthRateImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GrowthRate(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GrowthRate'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GrowthRateImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GrowthRateImplCopyWith<_$GrowthRateImpl> get copyWith =>
      __$$GrowthRateImplCopyWithImpl<_$GrowthRateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GrowthRateImplToJson(
      this,
    );
  }
}

abstract class _GrowthRate implements GrowthRate {
  const factory _GrowthRate(
      {required final String name,
      required final String url}) = _$GrowthRateImpl;

  factory _GrowthRate.fromJson(Map<String, dynamic> json) =
      _$GrowthRateImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$GrowthRateImplCopyWith<_$GrowthRateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Habitat _$HabitatFromJson(Map<String, dynamic> json) {
  return _Habitat.fromJson(json);
}

/// @nodoc
mixin _$Habitat {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $HabitatCopyWith<Habitat> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HabitatCopyWith<$Res> {
  factory $HabitatCopyWith(Habitat value, $Res Function(Habitat) then) =
      _$HabitatCopyWithImpl<$Res, Habitat>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$HabitatCopyWithImpl<$Res, $Val extends Habitat>
    implements $HabitatCopyWith<$Res> {
  _$HabitatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HabitatImplCopyWith<$Res> implements $HabitatCopyWith<$Res> {
  factory _$$HabitatImplCopyWith(
          _$HabitatImpl value, $Res Function(_$HabitatImpl) then) =
      __$$HabitatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$HabitatImplCopyWithImpl<$Res>
    extends _$HabitatCopyWithImpl<$Res, _$HabitatImpl>
    implements _$$HabitatImplCopyWith<$Res> {
  __$$HabitatImplCopyWithImpl(
      _$HabitatImpl _value, $Res Function(_$HabitatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$HabitatImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$HabitatImpl with DiagnosticableTreeMixin implements _Habitat {
  const _$HabitatImpl({required this.name, required this.url});

  factory _$HabitatImpl.fromJson(Map<String, dynamic> json) =>
      _$$HabitatImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Habitat(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Habitat'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HabitatImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HabitatImplCopyWith<_$HabitatImpl> get copyWith =>
      __$$HabitatImplCopyWithImpl<_$HabitatImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HabitatImplToJson(
      this,
    );
  }
}

abstract class _Habitat implements Habitat {
  const factory _Habitat(
      {required final String name, required final String url}) = _$HabitatImpl;

  factory _Habitat.fromJson(Map<String, dynamic> json) = _$HabitatImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$HabitatImplCopyWith<_$HabitatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Names _$NamesFromJson(Map<String, dynamic> json) {
  return _Names.fromJson(json);
}

/// @nodoc
mixin _$Names {
  Language get language => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NamesCopyWith<Names> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NamesCopyWith<$Res> {
  factory $NamesCopyWith(Names value, $Res Function(Names) then) =
      _$NamesCopyWithImpl<$Res, Names>;
  @useResult
  $Res call({Language language, String name});

  $LanguageCopyWith<$Res> get language;
}

/// @nodoc
class _$NamesCopyWithImpl<$Res, $Val extends Names>
    implements $NamesCopyWith<$Res> {
  _$NamesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LanguageCopyWith<$Res> get language {
    return $LanguageCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$NamesImplCopyWith<$Res> implements $NamesCopyWith<$Res> {
  factory _$$NamesImplCopyWith(
          _$NamesImpl value, $Res Function(_$NamesImpl) then) =
      __$$NamesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Language language, String name});

  @override
  $LanguageCopyWith<$Res> get language;
}

/// @nodoc
class __$$NamesImplCopyWithImpl<$Res>
    extends _$NamesCopyWithImpl<$Res, _$NamesImpl>
    implements _$$NamesImplCopyWith<$Res> {
  __$$NamesImplCopyWithImpl(
      _$NamesImpl _value, $Res Function(_$NamesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = null,
    Object? name = null,
  }) {
    return _then(_$NamesImpl(
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Language,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NamesImpl with DiagnosticableTreeMixin implements _Names {
  const _$NamesImpl({required this.language, required this.name});

  factory _$NamesImpl.fromJson(Map<String, dynamic> json) =>
      _$$NamesImplFromJson(json);

  @override
  final Language language;
  @override
  final String name;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Names(language: $language, name: $name)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Names'))
      ..add(DiagnosticsProperty('language', language))
      ..add(DiagnosticsProperty('name', name));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NamesImpl &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, language, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NamesImplCopyWith<_$NamesImpl> get copyWith =>
      __$$NamesImplCopyWithImpl<_$NamesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NamesImplToJson(
      this,
    );
  }
}

abstract class _Names implements Names {
  const factory _Names(
      {required final Language language,
      required final String name}) = _$NamesImpl;

  factory _Names.fromJson(Map<String, dynamic> json) = _$NamesImpl.fromJson;

  @override
  Language get language;
  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$NamesImplCopyWith<_$NamesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PalParkEncounters _$PalParkEncountersFromJson(Map<String, dynamic> json) {
  return _PalParkEncounters.fromJson(json);
}

/// @nodoc
mixin _$PalParkEncounters {
  Area get area => throw _privateConstructorUsedError;
  int get baseScore => throw _privateConstructorUsedError;
  int get rate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PalParkEncountersCopyWith<PalParkEncounters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PalParkEncountersCopyWith<$Res> {
  factory $PalParkEncountersCopyWith(
          PalParkEncounters value, $Res Function(PalParkEncounters) then) =
      _$PalParkEncountersCopyWithImpl<$Res, PalParkEncounters>;
  @useResult
  $Res call({Area area, int baseScore, int rate});

  $AreaCopyWith<$Res> get area;
}

/// @nodoc
class _$PalParkEncountersCopyWithImpl<$Res, $Val extends PalParkEncounters>
    implements $PalParkEncountersCopyWith<$Res> {
  _$PalParkEncountersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? area = null,
    Object? baseScore = null,
    Object? rate = null,
  }) {
    return _then(_value.copyWith(
      area: null == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as Area,
      baseScore: null == baseScore
          ? _value.baseScore
          : baseScore // ignore: cast_nullable_to_non_nullable
              as int,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AreaCopyWith<$Res> get area {
    return $AreaCopyWith<$Res>(_value.area, (value) {
      return _then(_value.copyWith(area: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PalParkEncountersImplCopyWith<$Res>
    implements $PalParkEncountersCopyWith<$Res> {
  factory _$$PalParkEncountersImplCopyWith(_$PalParkEncountersImpl value,
          $Res Function(_$PalParkEncountersImpl) then) =
      __$$PalParkEncountersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Area area, int baseScore, int rate});

  @override
  $AreaCopyWith<$Res> get area;
}

/// @nodoc
class __$$PalParkEncountersImplCopyWithImpl<$Res>
    extends _$PalParkEncountersCopyWithImpl<$Res, _$PalParkEncountersImpl>
    implements _$$PalParkEncountersImplCopyWith<$Res> {
  __$$PalParkEncountersImplCopyWithImpl(_$PalParkEncountersImpl _value,
      $Res Function(_$PalParkEncountersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? area = null,
    Object? baseScore = null,
    Object? rate = null,
  }) {
    return _then(_$PalParkEncountersImpl(
      area: null == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as Area,
      baseScore: null == baseScore
          ? _value.baseScore
          : baseScore // ignore: cast_nullable_to_non_nullable
              as int,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PalParkEncountersImpl
    with DiagnosticableTreeMixin
    implements _PalParkEncounters {
  const _$PalParkEncountersImpl(
      {required this.area, required this.baseScore, required this.rate});

  factory _$PalParkEncountersImpl.fromJson(Map<String, dynamic> json) =>
      _$$PalParkEncountersImplFromJson(json);

  @override
  final Area area;
  @override
  final int baseScore;
  @override
  final int rate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PalParkEncounters(area: $area, baseScore: $baseScore, rate: $rate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PalParkEncounters'))
      ..add(DiagnosticsProperty('area', area))
      ..add(DiagnosticsProperty('baseScore', baseScore))
      ..add(DiagnosticsProperty('rate', rate));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PalParkEncountersImpl &&
            (identical(other.area, area) || other.area == area) &&
            (identical(other.baseScore, baseScore) ||
                other.baseScore == baseScore) &&
            (identical(other.rate, rate) || other.rate == rate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, area, baseScore, rate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PalParkEncountersImplCopyWith<_$PalParkEncountersImpl> get copyWith =>
      __$$PalParkEncountersImplCopyWithImpl<_$PalParkEncountersImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PalParkEncountersImplToJson(
      this,
    );
  }
}

abstract class _PalParkEncounters implements PalParkEncounters {
  const factory _PalParkEncounters(
      {required final Area area,
      required final int baseScore,
      required final int rate}) = _$PalParkEncountersImpl;

  factory _PalParkEncounters.fromJson(Map<String, dynamic> json) =
      _$PalParkEncountersImpl.fromJson;

  @override
  Area get area;
  @override
  int get baseScore;
  @override
  int get rate;
  @override
  @JsonKey(ignore: true)
  _$$PalParkEncountersImplCopyWith<_$PalParkEncountersImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Area _$AreaFromJson(Map<String, dynamic> json) {
  return _Area.fromJson(json);
}

/// @nodoc
mixin _$Area {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AreaCopyWith<Area> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AreaCopyWith<$Res> {
  factory $AreaCopyWith(Area value, $Res Function(Area) then) =
      _$AreaCopyWithImpl<$Res, Area>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$AreaCopyWithImpl<$Res, $Val extends Area>
    implements $AreaCopyWith<$Res> {
  _$AreaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AreaImplCopyWith<$Res> implements $AreaCopyWith<$Res> {
  factory _$$AreaImplCopyWith(
          _$AreaImpl value, $Res Function(_$AreaImpl) then) =
      __$$AreaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$AreaImplCopyWithImpl<$Res>
    extends _$AreaCopyWithImpl<$Res, _$AreaImpl>
    implements _$$AreaImplCopyWith<$Res> {
  __$$AreaImplCopyWithImpl(_$AreaImpl _value, $Res Function(_$AreaImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$AreaImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AreaImpl with DiagnosticableTreeMixin implements _Area {
  const _$AreaImpl({required this.name, required this.url});

  factory _$AreaImpl.fromJson(Map<String, dynamic> json) =>
      _$$AreaImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Area(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Area'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AreaImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AreaImplCopyWith<_$AreaImpl> get copyWith =>
      __$$AreaImplCopyWithImpl<_$AreaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AreaImplToJson(
      this,
    );
  }
}

abstract class _Area implements Area {
  const factory _Area({required final String name, required final String url}) =
      _$AreaImpl;

  factory _Area.fromJson(Map<String, dynamic> json) = _$AreaImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$AreaImplCopyWith<_$AreaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PokedexNumbers _$PokedexNumbersFromJson(Map<String, dynamic> json) {
  return _PokedexNumbers.fromJson(json);
}

/// @nodoc
mixin _$PokedexNumbers {
  int get entryNumber => throw _privateConstructorUsedError;
  Pokedex get pokedex => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PokedexNumbersCopyWith<PokedexNumbers> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokedexNumbersCopyWith<$Res> {
  factory $PokedexNumbersCopyWith(
          PokedexNumbers value, $Res Function(PokedexNumbers) then) =
      _$PokedexNumbersCopyWithImpl<$Res, PokedexNumbers>;
  @useResult
  $Res call({int entryNumber, Pokedex pokedex});

  $PokedexCopyWith<$Res> get pokedex;
}

/// @nodoc
class _$PokedexNumbersCopyWithImpl<$Res, $Val extends PokedexNumbers>
    implements $PokedexNumbersCopyWith<$Res> {
  _$PokedexNumbersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? entryNumber = null,
    Object? pokedex = null,
  }) {
    return _then(_value.copyWith(
      entryNumber: null == entryNumber
          ? _value.entryNumber
          : entryNumber // ignore: cast_nullable_to_non_nullable
              as int,
      pokedex: null == pokedex
          ? _value.pokedex
          : pokedex // ignore: cast_nullable_to_non_nullable
              as Pokedex,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PokedexCopyWith<$Res> get pokedex {
    return $PokedexCopyWith<$Res>(_value.pokedex, (value) {
      return _then(_value.copyWith(pokedex: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PokedexNumbersImplCopyWith<$Res>
    implements $PokedexNumbersCopyWith<$Res> {
  factory _$$PokedexNumbersImplCopyWith(_$PokedexNumbersImpl value,
          $Res Function(_$PokedexNumbersImpl) then) =
      __$$PokedexNumbersImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int entryNumber, Pokedex pokedex});

  @override
  $PokedexCopyWith<$Res> get pokedex;
}

/// @nodoc
class __$$PokedexNumbersImplCopyWithImpl<$Res>
    extends _$PokedexNumbersCopyWithImpl<$Res, _$PokedexNumbersImpl>
    implements _$$PokedexNumbersImplCopyWith<$Res> {
  __$$PokedexNumbersImplCopyWithImpl(
      _$PokedexNumbersImpl _value, $Res Function(_$PokedexNumbersImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? entryNumber = null,
    Object? pokedex = null,
  }) {
    return _then(_$PokedexNumbersImpl(
      entryNumber: null == entryNumber
          ? _value.entryNumber
          : entryNumber // ignore: cast_nullable_to_non_nullable
              as int,
      pokedex: null == pokedex
          ? _value.pokedex
          : pokedex // ignore: cast_nullable_to_non_nullable
              as Pokedex,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PokedexNumbersImpl
    with DiagnosticableTreeMixin
    implements _PokedexNumbers {
  const _$PokedexNumbersImpl(
      {required this.entryNumber, required this.pokedex});

  factory _$PokedexNumbersImpl.fromJson(Map<String, dynamic> json) =>
      _$$PokedexNumbersImplFromJson(json);

  @override
  final int entryNumber;
  @override
  final Pokedex pokedex;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PokedexNumbers(entryNumber: $entryNumber, pokedex: $pokedex)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PokedexNumbers'))
      ..add(DiagnosticsProperty('entryNumber', entryNumber))
      ..add(DiagnosticsProperty('pokedex', pokedex));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PokedexNumbersImpl &&
            (identical(other.entryNumber, entryNumber) ||
                other.entryNumber == entryNumber) &&
            (identical(other.pokedex, pokedex) || other.pokedex == pokedex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, entryNumber, pokedex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PokedexNumbersImplCopyWith<_$PokedexNumbersImpl> get copyWith =>
      __$$PokedexNumbersImplCopyWithImpl<_$PokedexNumbersImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PokedexNumbersImplToJson(
      this,
    );
  }
}

abstract class _PokedexNumbers implements PokedexNumbers {
  const factory _PokedexNumbers(
      {required final int entryNumber,
      required final Pokedex pokedex}) = _$PokedexNumbersImpl;

  factory _PokedexNumbers.fromJson(Map<String, dynamic> json) =
      _$PokedexNumbersImpl.fromJson;

  @override
  int get entryNumber;
  @override
  Pokedex get pokedex;
  @override
  @JsonKey(ignore: true)
  _$$PokedexNumbersImplCopyWith<_$PokedexNumbersImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Pokedex _$PokedexFromJson(Map<String, dynamic> json) {
  return _Pokedex.fromJson(json);
}

/// @nodoc
mixin _$Pokedex {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PokedexCopyWith<Pokedex> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokedexCopyWith<$Res> {
  factory $PokedexCopyWith(Pokedex value, $Res Function(Pokedex) then) =
      _$PokedexCopyWithImpl<$Res, Pokedex>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$PokedexCopyWithImpl<$Res, $Val extends Pokedex>
    implements $PokedexCopyWith<$Res> {
  _$PokedexCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PokedexImplCopyWith<$Res> implements $PokedexCopyWith<$Res> {
  factory _$$PokedexImplCopyWith(
          _$PokedexImpl value, $Res Function(_$PokedexImpl) then) =
      __$$PokedexImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$PokedexImplCopyWithImpl<$Res>
    extends _$PokedexCopyWithImpl<$Res, _$PokedexImpl>
    implements _$$PokedexImplCopyWith<$Res> {
  __$$PokedexImplCopyWithImpl(
      _$PokedexImpl _value, $Res Function(_$PokedexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$PokedexImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PokedexImpl with DiagnosticableTreeMixin implements _Pokedex {
  const _$PokedexImpl({required this.name, required this.url});

  factory _$PokedexImpl.fromJson(Map<String, dynamic> json) =>
      _$$PokedexImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Pokedex(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Pokedex'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PokedexImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PokedexImplCopyWith<_$PokedexImpl> get copyWith =>
      __$$PokedexImplCopyWithImpl<_$PokedexImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PokedexImplToJson(
      this,
    );
  }
}

abstract class _Pokedex implements Pokedex {
  const factory _Pokedex(
      {required final String name, required final String url}) = _$PokedexImpl;

  factory _Pokedex.fromJson(Map<String, dynamic> json) = _$PokedexImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$PokedexImplCopyWith<_$PokedexImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Shape _$ShapeFromJson(Map<String, dynamic> json) {
  return _Shape.fromJson(json);
}

/// @nodoc
mixin _$Shape {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ShapeCopyWith<Shape> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShapeCopyWith<$Res> {
  factory $ShapeCopyWith(Shape value, $Res Function(Shape) then) =
      _$ShapeCopyWithImpl<$Res, Shape>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$ShapeCopyWithImpl<$Res, $Val extends Shape>
    implements $ShapeCopyWith<$Res> {
  _$ShapeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ShapeImplCopyWith<$Res> implements $ShapeCopyWith<$Res> {
  factory _$$ShapeImplCopyWith(
          _$ShapeImpl value, $Res Function(_$ShapeImpl) then) =
      __$$ShapeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$ShapeImplCopyWithImpl<$Res>
    extends _$ShapeCopyWithImpl<$Res, _$ShapeImpl>
    implements _$$ShapeImplCopyWith<$Res> {
  __$$ShapeImplCopyWithImpl(
      _$ShapeImpl _value, $Res Function(_$ShapeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$ShapeImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ShapeImpl with DiagnosticableTreeMixin implements _Shape {
  const _$ShapeImpl({required this.name, required this.url});

  factory _$ShapeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ShapeImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Shape(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Shape'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShapeImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShapeImplCopyWith<_$ShapeImpl> get copyWith =>
      __$$ShapeImplCopyWithImpl<_$ShapeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ShapeImplToJson(
      this,
    );
  }
}

abstract class _Shape implements Shape {
  const factory _Shape(
      {required final String name, required final String url}) = _$ShapeImpl;

  factory _Shape.fromJson(Map<String, dynamic> json) = _$ShapeImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$ShapeImplCopyWith<_$ShapeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Varieties _$VarietiesFromJson(Map<String, dynamic> json) {
  return _Varieties.fromJson(json);
}

/// @nodoc
mixin _$Varieties {
  bool get isDefault => throw _privateConstructorUsedError;
  Pokemon get pokemon => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VarietiesCopyWith<Varieties> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VarietiesCopyWith<$Res> {
  factory $VarietiesCopyWith(Varieties value, $Res Function(Varieties) then) =
      _$VarietiesCopyWithImpl<$Res, Varieties>;
  @useResult
  $Res call({bool isDefault, Pokemon pokemon});

  $PokemonCopyWith<$Res> get pokemon;
}

/// @nodoc
class _$VarietiesCopyWithImpl<$Res, $Val extends Varieties>
    implements $VarietiesCopyWith<$Res> {
  _$VarietiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isDefault = null,
    Object? pokemon = null,
  }) {
    return _then(_value.copyWith(
      isDefault: null == isDefault
          ? _value.isDefault
          : isDefault // ignore: cast_nullable_to_non_nullable
              as bool,
      pokemon: null == pokemon
          ? _value.pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as Pokemon,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PokemonCopyWith<$Res> get pokemon {
    return $PokemonCopyWith<$Res>(_value.pokemon, (value) {
      return _then(_value.copyWith(pokemon: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$VarietiesImplCopyWith<$Res>
    implements $VarietiesCopyWith<$Res> {
  factory _$$VarietiesImplCopyWith(
          _$VarietiesImpl value, $Res Function(_$VarietiesImpl) then) =
      __$$VarietiesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isDefault, Pokemon pokemon});

  @override
  $PokemonCopyWith<$Res> get pokemon;
}

/// @nodoc
class __$$VarietiesImplCopyWithImpl<$Res>
    extends _$VarietiesCopyWithImpl<$Res, _$VarietiesImpl>
    implements _$$VarietiesImplCopyWith<$Res> {
  __$$VarietiesImplCopyWithImpl(
      _$VarietiesImpl _value, $Res Function(_$VarietiesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isDefault = null,
    Object? pokemon = null,
  }) {
    return _then(_$VarietiesImpl(
      isDefault: null == isDefault
          ? _value.isDefault
          : isDefault // ignore: cast_nullable_to_non_nullable
              as bool,
      pokemon: null == pokemon
          ? _value.pokemon
          : pokemon // ignore: cast_nullable_to_non_nullable
              as Pokemon,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VarietiesImpl with DiagnosticableTreeMixin implements _Varieties {
  const _$VarietiesImpl({required this.isDefault, required this.pokemon});

  factory _$VarietiesImpl.fromJson(Map<String, dynamic> json) =>
      _$$VarietiesImplFromJson(json);

  @override
  final bool isDefault;
  @override
  final Pokemon pokemon;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Varieties(isDefault: $isDefault, pokemon: $pokemon)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Varieties'))
      ..add(DiagnosticsProperty('isDefault', isDefault))
      ..add(DiagnosticsProperty('pokemon', pokemon));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VarietiesImpl &&
            (identical(other.isDefault, isDefault) ||
                other.isDefault == isDefault) &&
            (identical(other.pokemon, pokemon) || other.pokemon == pokemon));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, isDefault, pokemon);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VarietiesImplCopyWith<_$VarietiesImpl> get copyWith =>
      __$$VarietiesImplCopyWithImpl<_$VarietiesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VarietiesImplToJson(
      this,
    );
  }
}

abstract class _Varieties implements Varieties {
  const factory _Varieties(
      {required final bool isDefault,
      required final Pokemon pokemon}) = _$VarietiesImpl;

  factory _Varieties.fromJson(Map<String, dynamic> json) =
      _$VarietiesImpl.fromJson;

  @override
  bool get isDefault;
  @override
  Pokemon get pokemon;
  @override
  @JsonKey(ignore: true)
  _$$VarietiesImplCopyWith<_$VarietiesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Pokemon _$PokemonFromJson(Map<String, dynamic> json) {
  return _Pokemon.fromJson(json);
}

/// @nodoc
mixin _$Pokemon {
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PokemonCopyWith<Pokemon> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PokemonCopyWith<$Res> {
  factory $PokemonCopyWith(Pokemon value, $Res Function(Pokemon) then) =
      _$PokemonCopyWithImpl<$Res, Pokemon>;
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class _$PokemonCopyWithImpl<$Res, $Val extends Pokemon>
    implements $PokemonCopyWith<$Res> {
  _$PokemonCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PokemonImplCopyWith<$Res> implements $PokemonCopyWith<$Res> {
  factory _$$PokemonImplCopyWith(
          _$PokemonImpl value, $Res Function(_$PokemonImpl) then) =
      __$$PokemonImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String url});
}

/// @nodoc
class __$$PokemonImplCopyWithImpl<$Res>
    extends _$PokemonCopyWithImpl<$Res, _$PokemonImpl>
    implements _$$PokemonImplCopyWith<$Res> {
  __$$PokemonImplCopyWithImpl(
      _$PokemonImpl _value, $Res Function(_$PokemonImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? url = null,
  }) {
    return _then(_$PokemonImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PokemonImpl with DiagnosticableTreeMixin implements _Pokemon {
  const _$PokemonImpl({required this.name, required this.url});

  factory _$PokemonImpl.fromJson(Map<String, dynamic> json) =>
      _$$PokemonImplFromJson(json);

  @override
  final String name;
  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Pokemon(name: $name, url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Pokemon'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PokemonImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PokemonImplCopyWith<_$PokemonImpl> get copyWith =>
      __$$PokemonImplCopyWithImpl<_$PokemonImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PokemonImplToJson(
      this,
    );
  }
}

abstract class _Pokemon implements Pokemon {
  const factory _Pokemon(
      {required final String name, required final String url}) = _$PokemonImpl;

  factory _Pokemon.fromJson(Map<String, dynamic> json) = _$PokemonImpl.fromJson;

  @override
  String get name;
  @override
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$PokemonImplCopyWith<_$PokemonImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
